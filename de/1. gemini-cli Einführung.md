## Gemini CLI: Einf√ºhrung und erste Schritte.

**Gemini CLI** ist ein Tool, das direkt in Ihrem Terminal funktioniert, Ihre Codebasis versteht und Ihnen hilft, Fehler mit Anfragen in nat√ºrlicher Sprache zu beheben. Dies ist Googles Antwort auf Anthropics Claude Code.
Sie k√∂nnen Gemini 2.5 Pro (bei Erreichen des Limits wechselt das Tool zu Gemini 2.5 Flash) und sein Kontextfenster von 1 Million Token verwenden, um bis zu 60 Anfragen pro Minute und 1000 Anfragen pro Tag auszuf√ºhren, und das alles kostenlos.

### Inhalt
*   Verstehen und Navigieren in gro√üen Codebasen
*   Fehlererkennung und -behebung
*   Schreiben und Testen von Code
*   Gemini CLI-Tools
*   Integration von Google CLI mit MCP

### Hauptmerkmale von Gemini CLI:
*   **Bearbeiten und Refactoring:** Verbessert und vereinfacht Ihren Code automatisch unter Anleitung der KI.
*   **Fehlererkennung und -behebung:** Findet Fehler und schl√§gt Korrekturen vor.
*   **Code-Verst√§ndnis:** Gemini CLI kann die Architektur zusammenfassen, die Rollen von Modulen erkl√§ren oder Ausf√ºhrungsflussdiagramme erstellen.
*   **Testgenerierung:** Erstellt automatisch Testaufgaben f√ºr `pytest`
*   **Dokumentationsunterst√ºtzung:** Sie k√∂nnen strukturierte Markdown-Dokumente, √Ñnderungslisten (Changelogs) und Antworten auf GitHub-Probleme direkt im Terminal erstellen.
*   **Befehlsausf√ºhrung:** Gemini CLI kann Shell-Befehle wie `git`, `npm`, `pip` und andere ausf√ºhren, sodass Sie Projekte verwalten k√∂nnen, ohne die CLI zu verlassen.

---


### Schritt 1: Voraussetzungen

Installieren Sie zun√§chst Node.js (Version 18 oder h√∂her). Sie k√∂nnen den Installer Ihrer Wahl herunterladen oder die folgenden Bash-Befehle in Ihrem Terminal ausf√ºhren:

```bash
# Herunterladen und Installieren von nvm (Node Version Manager):
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash

# Initialisieren von nvm in der aktuellen Terminalsitzung
. "$HOME/.nvm/nvm.sh"

# Herunterladen und Installieren von Node.js (z.B. Version 22):
nvm install 22

# √úberpr√ºfen der Node.js-Version:
node -v # Sollte "v22.17.0" oder √§hnlich ausgeben
# √úberpr√ºfen der npm-Version:
npm -v # Sollte "10.9.2" oder √§hnlich ausgeben
```

> ‚ö†Ô∏è **Wichtig f√ºr Windows-Benutzer:**
> Der oben genannte `nvm`-Befehl ist f√ºr **Linux/macOS** und **funktioniert nicht in PowerShell oder cmd.exe**.
> Verwenden Sie f√ºr Windows [nvm-windows](https://github.com/coreybutler/nvm-windows), indem Sie `nvm-setup.exe` aus dem Abschnitt [Releases](https://github.com/coreybutler/nvm-windows/releases) herunterladen.
> Alternativ k√∂nnen Sie WSL (Windows Subsystem for Linux) installieren und die Befehle in Ubuntu oder einer anderen Linux-Distribution ausf√ºhren.

---
### Schritt 2: Gemini CLI einrichten

#### Schritt 2.1: Gemini CLI installieren
Wenn Node.js und npm installiert und √ºberpr√ºft wurden, installieren Sie Gemini CLI, indem Sie den folgenden Befehl in Ihrem Terminal ausf√ºhren:
```bash
npx https://github.com/google-gemini/gemini-cli
```
Oder verwenden Sie `npm` f√ºr die globale Installation:
```bash
npm install -g @google/gemini-cli
gemini
```
Nach der Installation geben Sie `gemini` in das Terminal ein, um auf das Tool zuzugreifen.



#### Schritt 2.2: Authentifizierung
Sie k√∂nnen Ihr pers√∂nliches Google-Konto zur Authentifizierung verwenden. Dies erm√∂glicht Ihnen bis zu 60 Anfragen pro Minute und 1000 Anfragen pro Tag bei der Verwendung von Gemini.
![First Run](assets/gemini_cli_1/auth.png)

In diesem Handbuch habe ich **Anmeldung √ºber Google** verwendet, aber Sie k√∂nnen auch einen **API-Schl√ºssel** (als Umgebungsvariable oder in einer `.env`-Datei festgelegt) oder die Authentifizierung √ºber **Vertex AI** verwenden.

Um einen neuen API-Schl√ºssel zu generieren, melden Sie sich mit Ihrem Google-Konto bei **AI Studio** an und klicken Sie auf "API-Schl√ºssel erstellen".
```bash
# Schl√ºssel als Umgebungsvariable festlegen
export GEMINI_API_KEY="Your_API_Key"

# Oder erstellen Sie eine .env-Datei
GEMINI_API_KEY="Your_API_Key"
```
Sie k√∂nnen den Befehl `/auth` im Textfeld verwenden, um die Authentifizierungsmethode bei Bedarf zu wechseln.

---

### Schritt 3: Projekt in Gemini CLI einrichten
![Start](assets/gemini_cli_1/start.png)
Wenn die CLI gestartet ist, k√∂nnen wir mit Gemini √ºber das Terminal interagieren. Es gibt zwei M√∂glichkeiten, mit einem Projekt zu arbeiten.

#### 1. Ein neues Projekt starten
Um ein Projekt von Grund auf neu zu starten, f√ºhren Sie die folgenden Befehle aus:
```bash
cd new-project/
gemini
```
Verwenden Sie innerhalb der CLI die Eingabeaufforderung, um das Problem zu l√∂sen, das Sie interessiert, zum Beispiel:
> Schreiben Sie den Code eines Encoders f√ºr einen Transformer von Grund auf neu.
![Example 1](assets/gemini_cli_1/example_1.png)
Erteilen Sie die Berechtigung zum Schreiben von Dateien:
![File](assets/gemini_cli/file.png)

#### 2. Mit einem bestehenden Projekt arbeiten
Wenn Sie bereits eine Codebasis haben, k√∂nnen Sie damit arbeiten, indem Sie die folgenden Befehle ausf√ºhren:
```bash
git clone https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo
cd Google-Agent-Development-Kit-Demo
gemini
```
Verwenden Sie innerhalb der CLI eine Eingabeaufforderung, zum Beispiel:
> Geben Sie mir eine Zusammenfassung aller √Ñnderungen, die in den letzten Monat an der Codebasis vorgenommen wurden.

---

### Schritt 4: Experimente mit Gemini CLI
Als Beispiel werde ich das Projekt **[Reiseplaner üåçüõ´ basierend auf ADK](https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo)** verwenden.
Mit Gemini CLI zeige ich Ihnen, wie Sie:
1.  die Codebasis untersuchen
2.  einen Fehler oder ein Problem auf GitHub oder in einer Datei erkennen
3.  Code refaktorieren und Unit-Tests generieren
4.  einen Markdown-Bericht √ºber die vorgenommenen √Ñnderungen erstellen
5.  die Codebasis visualisieren, indem Sie ein Flussdiagramm generieren

#### Untersuchung und Verst√§ndnis der Codebasis
Beginnen wir damit, Gemini zu bitten, die Codebasis zu untersuchen und zu erkl√§ren.

**Eingabeaufforderung:** `Untersuchen Sie das aktuelle Verzeichnis und beschreiben Sie die Projektarchitektur.`

Gemini CLI gibt eine strukturierte Zusammenfassung zur√ºck, die die Architektur erkl√§rt:
*   **Benutzeroberfl√§che:** Die Streamlit-Anwendung (`travel_ui.py`) bietet eine Schnittstelle zur Interaktion.
*   **Orchestrierung:** `host_agent` fungiert als zentraler Koordinator.
*   **Spezialisierte Agenten:** `flight_agent`, `stay_agent`, `activities_agent` zum Suchen von Fl√ºgen, Hotels und Aktivit√§ten.
*   **Kommunikation:** Agenten kommunizieren √ºber RESTful APIs in FastAPI miteinander.
*   **Gemeinsame Komponenten:** `shared/schemas.py` definiert gemeinsame Datenstrukturen.

Dies hilft Ihnen, sich zurechtzufinden, ohne jede Datei manuell lesen zu m√ºssen.

#### Analyse und Behebung eines Problems auf GitHub
Untersuchen wir einige offene Probleme aus dem GitHub-Repository.

**Eingabeaufforderung:** `Hier ist ein Problem auf GitHub: [@search https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo/issues/1]. Analysieren Sie die Codebasis und schlagen Sie einen 3-Schritte-Plan zur Behebung vor. Welche Dateien/Funktionen sollten ge√§ndert werden?`

Gemini CLI hat das Problem untersucht:
*   Mithilfe der `@search`-Funktion wurden Daten von GitHub abgerufen.
*   Die Hauptursache wurde als JSON-Serialisierungsfehler identifiziert (in diesem Fall wurde die asynchrone Funktion `create_session()` nicht mit `await`).
*   Es wurden √Ñnderungen und die Verarbeitung der Antwort in mehreren Dateien vorgeschlagen.

Als N√§chstes wartet die CLI auf die Eingabe des Benutzers, um die √Ñnderungen zu bewerten. Wenn der Benutzer zustimmt, werden die vorgeschlagenen √Ñnderungen vorgenommen.

#### Implementierung und Testen der Korrektur
Nun implementieren und testen wir die von Gemini vorgeschlagenen Korrekturen.

**Eingabeaufforderung:** `Schreiben Sie einen Unit-Test f√ºr diese √Ñnderung in pytest in der Datei test_shared.py.`

Gemini CLI:
*   `json.dumps()` wurde vor dem Senden der Aufgaben-Payload eingef√ºgt.
*   `test_agents.py` wurde erstellt, um Unit-Tests hinzuzuf√ºgen.
*   Ein neuer Testfall wurde hinzugef√ºgt, um das Schema und die √úbertragung verschachtelter Agentennachrichten zu √ºberpr√ºfen.

#### Dokumentationsgenerierung
Nachdem die Korrekturen vorgenommen wurden, fassen wir die √Ñnderungen zusammen und speichern sie in Markdown in einer `.txt`-Datei.

**Eingabeaufforderung:** `Schreiben Sie eine Markdown-Zusammenfassung des Fehlers, der Korrektur und der Testabdeckung. Formatieren Sie dies als Eintrag im √Ñnderungslog unter Version "v0.2.0".`

Um die Zusammenfassung in einem Dokument zu speichern, habe ich dann die folgende Eingabeaufforderung verwendet:

**Eingabeaufforderung:** `Speichern Sie diese Zusammenfassung in einer .txt-Datei und nennen Sie sie summary.txt`

Gemini CLI verwendet das Tool `WriteFile` f√ºr die Speicherung der Datei `summary.txt` im Projektverzeichnis.

#### Generierung eines Flussdiagramms mit MCP
Dieser Abschnitt erweitert die vorherigen Experimente, in denen ich untersuche, wie Gemini CLI das **Model Context Protocol (MCP)** verwendet, um Zusammenfassungen auf Dateiebene und den Aufgabenverlauf zwischen Eingabeaufforderungen aufrechtzuerhalten. Dies gibt Gemini "Arbeitsged√§chtnis" innerhalb der Sitzung.

**Eingabeaufforderung:** `Generieren Sie ein Flussdiagramm, das zeigt, wie Agenten √ºber A2A (Agent-to-Agent) kommunizieren und wie main.py das System steuert. Heben Sie hervor, wo das Problem aufgetreten ist und wie es behoben wurde.`

Diese Visualisierung wurde durch das persistente Ged√§chtnis von Gemini erm√∂glicht, das den vollst√§ndigen Kontext unserer vorherigen Fehlerbehebung und Agentenstruktur speicherte, ohne dass Dateien erneut geladen werden mussten.

### Verf√ºgbare Gemini CLI-Tools
Der Aufruf des Befehls `/tools` in Gemini CLI zeigt eine Liste der verf√ºgbaren Tools an, die f√ºr verschiedene Aufgaben wie Codebearbeitung, Testgenerierung, Dokumentationserstellung und vieles mehr verwendet werden k√∂nnen.
![Tools](assets/gemini_cli_1/tools.png)

**ReadFolder (ls)**
Listet Dateien und Ordner in einem Verzeichnis auf ‚Äì analog zum Befehl `ls` in der Befehlszeile.

**ReadFile (read-file)**
Liest den vollst√§ndigen Inhalt einer einzelnen Datei, was n√ºtzlich ist, um Zusammenfassungen zu erstellen oder Analysen durchzuf√ºhren.

**ReadManyFiles (read-many-files)**
Liest mehrere Dateien gleichzeitig, normalerweise nach einem Muster (z. B. alle Dateien `.js`).

**FindFiles (glob)**
Sucht Dateien nach einem Muster (z. B. alle Dateien `config.json` in Ihrem Projekt finden).

**SearchText (grep)**
Sucht Text in Dateien, z. B. um alle `TODO`-Kommentare zu finden.

**Edit (edit)**
Wendete √Ñnderungen im Code mit `diff` an. Gemini zeigt eine Vorschau der √Ñnderungen an und fordert eine Best√§tigung, bevor sie angewendet werden.

**WriteFile (write-file)**
Erstellt neue Dateien (z. B. `README.md`) mit vom Benutzer bereitgestelltem Inhalt.

**Shell (shell)**
F√ºhrt Befehle direkt im Terminal aus, wenn Sie ihnen ein `!` voranstellen (z. B. `!npm test`).

**WebFetch (web-fetch)**
L√§dt Inhalte aus dem Web (HTML oder JSON) herunter, sodass Gemini externe Daten analysieren kann.

**GoogleSearch (web-search)**
F√ºhrt eine Google-Suche durch, um Antworten auf der Grundlage realer Informationen zu finden (z. B. um eine Fehlererkl√§rung zu finden).

**Save Memory (memoryTool)**
Speichert Fakten oder Pr√§ferenzen w√§hrend der Sitzung (z. B. ‚Äûich bevorzuge async/await‚Äú), um die Konsistenz und Koh√§renz der Antworten zu verbessern.


### Erweiterte Funktionen

Sie k√∂nnen spezielle Anweisungen f√ºr die KI f√ºr ein bestimmtes Projekt hinzuf√ºgen, 
indem Sie eine Datei `GEMINI.md` im Stammverzeichnis Ihres Projekts erstellen. 
In dieser Datei k√∂nnen Sie Projektregeln, 
Codestile und Tools definieren, die der Agent verwenden soll. Dies stellt sicher, dass der generierte Code den Standards Ihres Projekts entspricht.

[Beispiel f√ºr eine Systemanweisung](https://github.com/hypo69/hypotez/blob/master/src/endpoints/hypo69/code_assistant/instructions/CODE_RULES.EN.MD)

### Integration von Google CLI mit MCP

F√ºr die meisten allt√§glichen Aufgaben reichen die integrierten Tools aus. Aber was, wenn Sie m√∂chten, dass Gemini CLI etwas sehr Spezielles tut, z. B. mit bestimmten APIs interagiert oder ein spezialisiertes Modell (z. B. einen Bildgenerator oder ein Tool zur Sicherheitsanalyse) verwendet? Genau hier kommt MCP (Model Context Protocol) ins Spiel.

Im Wesentlichen ist MCP ein offener Standard, der es Entwicklern erm√∂glicht, der KI neue Tools und Funktionen hinzuzuf√ºgen, indem sie einen Server starten, mit dem die CLI kommunizieren kann. In Gemini CLI k√∂nnen Sie "MCP-Server" in einer JSON-Einstellungsdatei konfigurieren, und die CLI behandelt sie als zus√§tzliche Tools, die sie verwenden kann.

#### So richten Sie einen MCP-Server in Google CLI ein

Als Beispiel zeige ich Ihnen, wie Sie einen MCP-Server f√ºr GitHub in Gemini CLI einrichten.

Erstellen Sie im Ordner Ihres Projekts einen Ordner mit dem Befehl:

```bash
mkdir -p .gemini && touch .gemini/settings.json
```
F√ºllen Sie die Datei mit diesem Code:
```json
{  
  "mcpServers": {  
    "github": {  
      "command": "npx",  
      "args": ["-y", "@modelcontextprotocol/server-github"],  
      "env": { "GITHUB_PERSONAL_ACCESS_TOKEN": "[YOUR-TOKEN]" }  
    }  
  }  
}
```
[Anleitung zum Abrufen eines Tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic)
Danach geben Sie `/quit` in Gemini CLI ein, um zu beenden, und √∂ffnen Sie es dann erneut.
Sie werden sehen, dass der GitHub MCP-Server gestartet und einsatzbereit ist.
![MCP](assets/gemini_cli_1/mcp.png)
Danach geben Sie den Befehl `/mcp` ein, und Sie sehen eine Liste der GitHub-Tools.
![Mcp Commands](assets/gemini_cli_1/mcp_commands.png)