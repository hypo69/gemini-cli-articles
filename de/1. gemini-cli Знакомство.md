## Gemini CLI: Einf√ºhrung und erste Schritte.

**Gemini CLI** ist ein Tool, das direkt in Ihrem Terminal arbeitet, Ihre Codebasis versteht und Fehler mithilfe von Anfragen in nat√ºrlicher Sprache behebt. Dies ist Googles Antwort auf Anthropic's Claude Code.
Sie k√∂nnen Gemini 2.5 Pro (bei Erreichen des Limits wechselt das Tool zu Gemini 2.5 Flash) und sein 1-Millionen-Token-Kontextfenster verwenden, um bis zu 60 Anfragen pro Minute und 1000 Anfragen pro Tag auszuf√ºhren, und das alles kostenlos.

### Inhalt
*   Verstehen und Navigieren in gro√üen Codebasen
*   Fehlererkennung und -behebung
*   Code schreiben und testen
*   Gemini CLI-Tools
*   Google CLI-Integration mit MCP

### Hauptfunktionen von Gemini CLI:
*   **Bearbeiten und Refactoring:** Verbessert und vereinfacht Ihren Code automatisch unter Anleitung von KI.
*   **Fehlererkennung und -behebung:** Findet Fehler und schl√§gt Korrekturen vor.
*   **Code-Verst√§ndnis:** Gemini CLI kann Architekturen zusammenfassen, Modulrollen erkl√§ren oder Ausf√ºhrungsflussdiagramme erstellen.
*   **Testgenerierung:** Erstellt automatisch Testaufgaben f√ºr `pytest`.
*   **Dokumentationsunterst√ºtzung:** Sie k√∂nnen strukturierte Markdown-Dokumente, √Ñnderungslisten (Changelogs) und Antworten auf GitHub-Probleme direkt im Terminal erstellen.
*   **Befehlsausf√ºhrung:** Gemini CLI kann Shell-Befehle wie `git`, `npm`, `pip` und andere ausf√ºhren, sodass Sie Projekte verwalten k√∂nnen, ohne die CLI zu verlassen.

---


### Schritt 1: Voraussetzungen

Installieren Sie zun√§chst Node.js (Version 18 oder h√∂her). Sie k√∂nnen den Installer Ihrer Wahl herunterladen oder die folgenden Bash-Befehle in Ihrem Terminal ausf√ºhren:

```bash
# Herunterladen und Installieren von nvm (Node Version Manager):
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash

# nvm in der aktuellen Terminalsitzung initialisieren
. "$HOME/.nvm/nvm.sh"

# Herunterladen und Installieren von Node.js (z. B. Version 22):
nvm install 22

# Node.js-Version √ºberpr√ºfen:
node -v # Sollte "v22.17.0" oder √§hnliches ausgeben

# npm-Version √ºberpr√ºfen:
npm -v # Sollte "10.9.2" oder √§hnliches ausgeben
```

> ‚ö†Ô∏è **Wichtig f√ºr Windows-Benutzer:**
> Der oben genannte `nvm`-Befehl ist f√ºr **Linux/macOS** und **funktioniert nicht in PowerShell oder cmd.exe**.
> F√ºr Windows verwenden Sie [nvm-windows](https://github.com/coreybutler/nvm-windows), indem Sie `nvm-setup.exe` aus dem Abschnitt [Releases](https://github.com/coreybutler/nvm-windows/releases) herunterladen.
> Alternativ k√∂nnen Sie WSL (Windows Subsystem for Linux) installieren und die Befehle in Ubuntu oder einer anderen Linux-Distribution ausf√ºhren.

---
### Schritt 2: Gemini CLI einrichten

#### Schritt 2.1: Gemini CLI installieren
Nachdem Node.js und npm installiert und √ºberpr√ºft wurden, installieren Sie Gemini CLI, indem Sie den folgenden Befehl in Ihrem Terminal ausf√ºhren:
```bash
npx https://github.com/google-gemini/gemini-cli
```
Oder verwenden Sie `npm` f√ºr die globale Installation:
```bash
npm install -g @google/gemini-cli
gemini
```
Geben Sie nach der Installation `gemini` in das Terminal ein, um auf das Tool zuzugreifen.



#### Schritt 2.2: Authentifizierung
Sie k√∂nnen Ihr pers√∂nliches Google-Konto zur Authentifizierung verwenden. Dies erm√∂glicht Ihnen bis zu 60 Anfragen pro Minute und 1000 Anfragen pro Tag bei der Verwendung von Gemini.
![First Run](assets/gemini_cli_1/auth.png)

In diesem Handbuch habe ich **Mit Google anmelden** verwendet, Sie k√∂nnen aber auch einen **API-Schl√ºssel** (als Umgebungsvariable oder in einer `.env`-Datei festgelegt) oder die **Vertex AI**-Authentifizierung verwenden.

Um einen neuen API-Schl√ºssel zu generieren, melden Sie sich bei **AI Studio** mit Ihrem Google-Konto an und klicken Sie auf "API-Schl√ºssel erstellen".
```bash
# Schl√ºssel als Umgebungsvariable festlegen
export GEMINI_API_KEY="Your_API_Key"

# Oder eine .env-Datei erstellen
GEMINI_API_KEY="Your_API_Key"
```
Sie k√∂nnen den Befehl `/auth` im Textfeld verwenden, um die Authentifizierungsmethode bei Bedarf zu wechseln.

---

### Schritt 3: Projekteinrichtung in Gemini CLI
![Start](assets/gemini_cli_1/start.png)
Sobald die CLI l√§uft, k√∂nnen wir mit Gemini √ºber das Terminal interagieren. Es gibt zwei M√∂glichkeiten, mit einem Projekt zu arbeiten.

#### 1. Ein neues Projekt starten
Um ein Projekt von Grund auf neu zu starten, f√ºhren Sie die folgenden Befehle aus:
```bash
cd new-project/
gemini
```
Verwenden Sie innerhalb der CLI eine Eingabeaufforderung, um das Problem zu l√∂sen, das Sie interessiert, zum Beispiel:
> Schreiben Sie den Code eines Encoders f√ºr einen Transformer von Grund auf neu.
![Example 1](assets/gemini_cli_1/example_1.png)
Erlaubnis zum Schreiben von Dateien erteilen:
![File](assets/gemini_cli/file.png)

#### 2. Mit einem bestehenden Projekt arbeiten
Wenn Sie bereits eine Codebasis haben, k√∂nnen Sie damit arbeiten, indem Sie die folgenden Befehle ausf√ºhren:
```bash
git clone https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo
cd Google-Agent-Development-Kit-Demo
gemini
```
Verwenden Sie innerhalb der CLI eine Eingabeaufforderung, zum Beispiel:
> Geben Sie mir eine Zusammenfassung aller √Ñnderungen, die in den letzten Monat an der Codebasis vorgenommen wurden.

---

### Schritt 4: Experimente mit Gemini CLI
Als Beispiel verwende ich das Projekt **[ADK-basierter üåçüõ´ Reiseplaner](https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo)**.
Mit Gemini CLI zeige ich, wie man:
1.  die Codebasis erkundet
2.  einen Fehler oder ein Problem auf GitHub oder in einer Datei erkennt
3.  Code refaktoriert und Unit-Tests generiert
4.  einen Markdown-Bericht √ºber die vorgenommenen √Ñnderungen erstellt
5.  die Codebasis visualisiert, indem ein Flussdiagramm generiert wird

#### Erkundung und Verst√§ndnis der Codebasis
Beginnen wir damit, Gemini zu bitten, die Codebasis zu erkunden und zu erkl√§ren.

**Eingabeaufforderung:** `Erkunden Sie das aktuelle Verzeichnis und beschreiben Sie die Projektarchitektur.`

Gemini CLI gibt eine strukturierte Zusammenfassung zur√ºck, die die Architektur erkl√§rt:
*   **Benutzeroberfl√§che:** Die Streamlit-Anwendung (`travel_ui.py`) bietet eine Schnittstelle zur Interaktion.
*   **Orchestrierung:** `host_agent` fungiert als zentraler Koordinator.
*   **Spezialisierte Agenten:** `flight_agent`, `stay_agent`, `activities_agent` zur Suche nach Fl√ºgen, Hotels und Aktivit√§ten.
*   **Kommunikation:** Agenten kommunizieren √ºber eine FastAPI RESTful API miteinander.
*   **Gemeinsame Komponenten:** `shared/schemas.py` definiert gemeinsame Datenstrukturen.

Dies hilft, sich zu orientieren, ohne jede Datei manuell lesen zu m√ºssen.

#### Analyse und Behebung eines GitHub-Problems
Lassen Sie uns einige offene Probleme aus dem GitHub-Repository untersuchen.

**Eingabeaufforderung:** `Hier ist ein GitHub-Problem: [@search https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo/issues/1]. Analysieren Sie die Codebasis und schlagen Sie einen 3-Schritte-Fix-Plan vor. Welche Dateien/Funktionen sollten ge√§ndert werden?`

Gemini CLI hat das Problem untersucht:
*   Mithilfe der `@search`-Funktion wurden Daten von GitHub abgerufen.
*   Die Grundursache wurde als JSON-Serialisierungsfehler identifiziert (in diesem Fall wurde die asynchrone Funktion `create_session()` nicht mit `await` aufgerufen).
*   Vorgeschlagene √Ñnderungen und Antwortverarbeitung in mehreren Dateien.

Als N√§chstes wartet die CLI auf Benutzereingaben, um die √Ñnderungen zu bewerten. Wenn der Benutzer zustimmt, werden die vorgeschlagenen √Ñnderungen angewendet.

#### Implementierung und Test des Fixes
Nun implementieren und testen wir die von Gemini vorgeschlagenen Korrekturen.

**Eingabeaufforderung:** `Schreiben Sie einen Unit-Test f√ºr diese √Ñnderung in pytest in der Datei test_shared.py.`

Gemini CLI:
*   F√ºgte `json.dumps()` vor dem Senden der Aufgaben-Payload ein.
*   Erstellte `test_agents.py` um Unit-Tests hinzuzuf√ºgen.
*   F√ºgte einen neuen Testfall hinzu, um das Schema und die verschachtelte Agenten-Nachrichten√ºbertragung zu √ºberpr√ºfen.

#### Dokumentation generieren
Nachdem die Korrekturen vorgenommen wurden, fassen wir die √Ñnderungen zusammen und speichern sie in Markdown in einer `.txt`-Datei.

**Eingabeaufforderung:** `Schreiben Sie eine Markdown-Zusammenfassung des Fehlers, der Korrektur und der Testabdeckung. Formatieren Sie sie als Changelog-Eintrag unter Version "v0.2.0".`

Um die Zusammenfassung in einem Dokument zu speichern, habe ich dann die folgende Eingabeaufforderung verwendet:

**Eingabeaufforderung:** `Speichern Sie diese Zusammenfassung in einer .txt-Datei und nennen Sie sie summary.txt`

Gemini CLI verwendet das `WriteFile`-Tool, um die Datei `summary.txt` im Projektverzeichnis zu speichern.

#### Erstellen eines Flussdiagramms mit MCP
Dieser Abschnitt erweitert fr√ºhere Experimente, in denen ich untersuche, wie Gemini CLI das **Model Context Protocol (MCP)** verwendet, um Zusammenfassungen auf Dateiebene und den Aufgabenverlauf zwischen Eingabeaufforderungen zu verwalten. Dies gibt Gemini ein "Arbeitsged√§chtnis" innerhalb einer Sitzung.

**Eingabeaufforderung:** `Erstellen Sie ein Flussdiagramm, das zeigt, wie Agenten √ºber A2A (Agent-to-Agent) kommunizieren und wie main.py das System verwaltet. Heben Sie hervor, wo das Problem aufgetreten ist und wie es behoben wurde.`

Diese Visualisierung wurde durch das persistente Ged√§chtnis von Gemini erm√∂glicht, das den vollst√§ndigen Kontext unserer vorherigen Fehlerbehebung und Agentenstruktur beibehielt, ohne dass Dateien neu geladen werden mussten.

### Verf√ºgbare Gemini CLI-Tools
Der Aufruf des Befehls `/tools` in Gemini CLI zeigt eine Liste der verf√ºgbaren Tools, die f√ºr verschiedene Aufgaben verwendet werden k√∂nnen, wie z. B. Code bearbeiten, Tests generieren, Dokumentation erstellen und vieles mehr.
![Tools](assets/gemini_cli_1/tools.png)

**ReadFolder (ls)**
Listet Dateien und Ordner in einem Verzeichnis ‚Äì analog zum `ls`-Befehl in der Befehlszeile.

**ReadFile (read-file)**
Liest den vollst√§ndigen Inhalt einer einzelnen Datei, n√ºtzlich zum Erstellen von Zusammenfassungen oder Analysen.

**ReadManyFiles (read-many-files)**
Liest mehrere Dateien gleichzeitig, normalerweise nach Muster (z. B. alle `.js`-Dateien).

**FindFiles (glob)**
Sucht Dateien nach Muster (z. B. alle `config.json`-Dateien in Ihrem Projekt finden).

**SearchText (grep)**
Sucht Text in Dateien, z. B. um alle `TODO`-Kommentare zu finden.

**Edit (edit)**
Wendet Code√§nderungen mit `diff` an. Gemini zeigt eine Vorschau der Bearbeitungen an und fragt vor der Anwendung um Best√§tigung.

**WriteFile (write-file)**
Erstellt neue Dateien (z. B. `README.md`) mit vom Benutzer bereitgestelltem Inhalt.

**Shell (shell)**
F√ºhrt Befehle direkt im Terminal aus, wenn Sie ihnen ein `!` voranstellen (z. B. `!npm test`).

**WebFetch (web-fetch)**
L√§dt Inhalte aus dem Web (HTML oder JSON) herunter, sodass Gemini externe Daten analysieren kann.

**GoogleSearch (web-search)**
F√ºhrt eine Google-Suche durch, um Antworten auf realen Informationen zu basieren (z. B. um eine Erkl√§rung f√ºr einen Fehler zu finden).

**Save Memory (memoryTool)**
Speichert Fakten oder Pr√§ferenzen w√§hrend einer Sitzung (z. B. ‚ÄûIch bevorzuge async/await‚Äú), um die Konsistenz und Koh√§renz der Antworten zu verbessern.

### Erweiterte Funktionen

Sie k√∂nnen spezielle Anweisungen f√ºr die KI f√ºr ein bestimmtes Projekt hinzuf√ºgen,
indem Sie eine `GEMINI.md`-Datei im Stammverzeichnis Ihres Projekts erstellen.
In dieser Datei k√∂nnen Sie Projektregeln,
Codestile und Tools definieren, die der Agent verwenden soll. Dies stellt sicher, dass der generierte Code den Standards Ihres Projekts entspricht.

[Beispiel f√ºr Systemanweisungen](https://github.com/hypo69/hypotez/blob/master/src/endpoints/hypo69/code_assistant/instructions/CODE_RULES.EN.MD)

### Google CLI-Integration mit MCP

F√ºr die meisten allt√§glichen Aufgaben reichen die integrierten Tools aus. Aber was, wenn Sie m√∂chten, dass Gemini CLI etwas hochspezialisiertes tut, wie z. B. mit bestimmten APIs interagiert oder ein spezialisiertes Modell verwendet (z. B. einen Bildgenerator oder ein Sicherheitsanalysetool)? Hier kommt MCP (Model Context Protocol) ins Spiel.

Im Wesentlichen ist MCP ein offener Standard, der es Entwicklern erm√∂glicht, der KI neue Tools und Funktionen hinzuzuf√ºgen, indem sie einen Server betreiben, mit dem die CLI interagieren kann. In Gemini CLI k√∂nnen Sie "MCP-Server" in einer JSON-Einstellungsdatei konfigurieren, und die CLI behandelt sie als zus√§tzliche Tools, die sie verwenden kann.

#### So richten Sie einen MCP-Server in Google CLI ein

Als Beispiel zeige ich Ihnen, wie Sie einen MCP-Server f√ºr GitHub in Gemini CLI einrichten.

Erstellen Sie in Ihrem Projektordner einen Ordner mit dem Befehl:

```bash
mkdir -p .gemini && touch .gemini/settings.json
```
F√ºllen Sie die Datei mit diesem Code:
```json
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": { "GITHUB_PERSONAL_ACCESS_TOKEN": "[YOUR-TOKEN]" }
    }
  }
}
```
[Anleitung zum Abrufen eines Tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic)
Geben Sie danach `/quit` in Gemini CLI ein, um das Programm zu beenden, und √∂ffnen Sie es dann erneut.
Sie werden sehen, dass der GitHub MCP-Server l√§uft und einsatzbereit ist.
![MCP](assets/gemini_cli_1/mcp.png)
Geben Sie den Befehl `/mcp` ein, und Sie sehen eine Liste der GitHub-Tools.
![Mcp Commands](assets/gemini_cli_1/mcp_commands.png)
