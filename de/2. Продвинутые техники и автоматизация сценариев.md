## Gemini CLI: Fortgeschrittene Techniken und Szenario-Automatisierung.

Im ersten Teil haben wir die Grundlagen behandelt: Installation, Authentifizierung und Ausführung einzelner Befehle. Nun gehen wir zum nächsten Level über. In diesem Teil werden wir Gemini CLI beibringen, komplexe, mehrstufige Szenarien auszuführen, die gespeichert, wiederverwendet und mit dem Team geteilt werden können. Dies wird das Tool von einem einfachen Assistenten in eine leistungsstarke Automatisierungs-Engine verwandeln.

### Szenario-Ausführungsmechanismus

Die Kernidee ist, `.md`-Dateien als "Rezepte" oder "Szenarien" für Gemini zu verwenden. Innerhalb einer solchen Datei beschreiben wir in natürlicher Sprache die Abfolge der Aktionen, die die KI ausführen soll.

Um ein Szenario auszuführen, verwenden wir das integrierte `ReadFile`-Tool. Wir werden Gemini einfach bitten, die Datei mit Anweisungen zu lesen und diese auszuführen.

**Hauptbefehl zum Ausführen eines beliebigen Szenarios:**
```
> Lesen und Ausführen von Anweisungen aus der Datei 'szenario_name.md'
```

Schauen wir uns nun einige nützliche Szenarien an.

Erstellen Sie ein `scenarios`-Verzeichnis.
```bash
/path/to/gemini-cli > mkdir scenarios
```

darin werden wir unsere Szenarien speichern.

### Szenario: "Git-Repository-Audit"

Diese Aufgabe ist jedem Entwickler vertraut: Vor Arbeitsbeginn müssen Sie den aktuellen Zustand des Projekts überprüfen. Erstellen wir ein Szenario, das dies für uns erledigt.

1.  **Erstellen Sie im Verzeichnis `scenarios` die Datei `git-health-check.md`** mit folgendem Inhalt:

    ```markdown
    Sie sind ein erfahrener Git-Ingenieur. Ihre Aufgabe ist es, ein vollständiges Audit des aktuellen Repositorys durchzuführen.
    
    Führen Sie die folgenden Schritte streng der Reihe nach aus und warten Sie auf meine Bestätigung für jeden Befehl:
    
    1.  **Status prüfen:** Zeigen Sie mir den aktuellen Repository-Status, um nicht verfolgte oder geänderte Dateien zu sehen. Schlagen Sie den Befehl `!git status` vor.
    2.  **Updates abrufen:** Holen Sie die neuesten Änderungen vom Remote-Server, aber wenden Sie sie nicht an. Schlagen Sie den Befehl `!git fetch origin` vor.
    3.  **Branches vergleichen:** Zeigen Sie mir den Unterschied zwischen meinem lokalen `main`-Branch und dem Remote-`origin/main`-Branch. Schlagen Sie den Befehl `!git log main..origin/main --oneline` vor.
    4.  **Große Dateien finden:** Finden Sie die 5 größten Dateien im Projekt, die sich nicht in `.git` befinden. Schlagen Sie den Befehl `!find . -type f -not -path "./.git/*" -printf "%s %p\n" | sort -rn | head -n 5` vor.
    5.  **Zusammenfassen:** Beschreiben Sie abschließend kurz den Zustand des Repositorys basierend auf den erhaltenen Daten.
    ```

2.  **Führen Sie das Szenario in Gemini CLI aus:**

    ```
    > Lesen und Ausführen des Szenarios 'git-health-check.md'
    ```

![1](assets/1.png)


Tatsächlich gibt es in diesem Verzeichnis kein Repository, Gemini wird anbieten, ein neues Repository zu erstellen.
Gemini CLI wird Fehler bei der Repository-Erstellung selbstständig korrigieren, z. B. wenn Sie vergessen haben, es zu initialisieren, wird es dies vorschlagen,
sowie aktuelle Fehler während der Szenarioausführung.

## Schritt 1: Statusprüfung

![2](assets/2.png)


Antwort von Gemini:
```text
>✦ Ich bin ein erfahrener Git-Ingenieur. Ich beginne mit dem Audit Ihres Repositorys.
> Schritt 1: Statusprüfung
>Um den aktuellen Repository-Status zu überprüfen und nicht verfolgte oder geänderte Dateien zu sehen, werde ich den Befehl `git status` ausführen.
```
Ausführung des Befehls `git status`...
![3](assets/3.png)


Antwort von Gemini:
```text
✦ Fehler: C:\Users\user\Documents\repos ist kein Git-Repository.

  Bitte geben Sie an, in welchem Unterverzeichnis ich das Audit ausführen soll. Zum Beispiel public_repositories.
```
Wir bitten darum, ein neues Repository zu erstellen.
![4](assets/4.png)
Antwort von Gemini:
```text
✦ Großartig, das Git-Repository wurde erstellt. Jetzt kann ich das Audit fortsetzen.


  Führe git status aus, um nach nicht verfolgten Dateien zu suchen.
```
![5](assets/5.png)

...

![6](assets/6.png)

Antwort von Gemini:
```text
✦ Es gibt viele nicht verfolgte Dateien und Ordner im Repository. Um fortzufahren, muss ich sie zum Index hinzufügen. Ich werde alle Dateien hinzufügen.
```

![7](assets/7.png)
...
![8](assets/8.png)

Beim Ausführen des Befehls ist ein Fehler aufgetreten
```text
error: pathspec 'commit"' did not match any file(s) known to git
```
Antwort von Gemini:
```text
✦ Es scheint, dass ein Anführungszeichenfehler im Befehl vorlag. Ich werde es erneut versuchen, indem ich einfache Anführungszeichen für die Commit-Nachricht verwende.
```

![9](assets/9.png)
![10](assets/10.png)
Diesmal hat es funktioniert!

Antwort von Gemini:
```text
✦ Großartig, der erste Commit wurde erfolgreich erstellt. Jetzt werde ich die temporäre Datei mit der Commit-Nachricht löschen.
```
Jetzt löscht Gemini die temporäre Datei mit der Commit-Nachricht.

Gemini CLI wendet die relevanten Befehle (`rm`, `del`) nacheinander an.

![11](assets/11.png)



### Schritt 2: Updates abrufen
Da das Remote-Repository nicht existiert, erhält Gemini CLI einen Fehler.
Beachten Sie, dass es selbst einen Fehler erwartet.

![12](assets/12.png)

### Schritt 3: Branches vergleichen

Hier wird es auch einen Fehler geben, da der `main`-Branch nicht existiert.
![13](assets/13.png)

###   Schritt 4: Große Dateien finden

![14](assets/14.png)
Antwort von Gemini:
```text
Der `find`-Befehl hat nicht funktioniert, weil Sie unter Windows `dir` verwenden müssen. Gemini wird den Fehler selbst korrigieren und den richtigen Befehl vorschlagen.

Danach überlegt Gemini CLI über die nächsten Schritte:
✦ THINK: The user wants me to find the 5 largest files in the project.
  The previous command find . -type f -not -path ".\.git\*" -printf "%s %p\n" | sort -rn | head -n 5 failed because find, sort, and head
  are not native Windows commands. I need to use a PowerShell equivalent.

   1. Get all files: Get-ChildItem -Recurse -File
   2. Exclude .git directory: Where-Object { $_.FullName -notlike "*.git\*" }
   3. Sort by size (descending): Sort-Object -Property Length -Descending
   4. Select the top 5: Select-Object -First 5
   5. Format the output: ForEach-Object { "{0} {1}" -f $_.Length, $_.FullName }

  Let's combine these into a single PowerShell command.Es scheint, dass find und head in Ihrer Windows-Umgebung nicht verfügbar sind. Ich werde PowerShell verwenden,
  um dieselbe Aufgabe auszuführen.
```
![15](assets/15.png)

Erneut ein Fehler.

Gemini CLI überlegt weiter, was als Nächstes zu tun ist:
```text
 
✦ THINK: The user wants to find the 5 largest files.
  The PowerShell command is still not executing correctly. It seems that the pipe | and special characters are being misinterpreted by the
  shell when passed as a single command string.

  I will try to execute the command by first saving the script to a file and then executing the file with PowerShell.

   1. Create a PowerShell script file (find_large_files.ps1).
   2. The content of the script will be: Get-ChildItem -Recurse -File | Where-Object { $_.FullName -notlike "*.git\*" } | Sort-Object
      -Property Length -Descending | Select-Object -First 5 | Format-Table Length, FullName -AutoSize
   3. Execute the script using powershell -File find_large_files.ps1.
   4. Delete the script file.Es scheint, dass die direkte Übergabe komplexer Befehle an PowerShell Probleme verursacht. Ich werde eine temporäre PowerShell-Skriptdatei erstellen,
      ausführen und dann löschen.

```
![16](assets/16.png)

Diesmal hat alles funktioniert!

### Schritt 5: Zusammenfassung
Gemini CLI fasst zusammen:
```text
 Repository-Status:

   * Lokales Repository: Initialisiert, und alle Dateien im Stammordner C:\Users\user\Documents\repos wurden dem ersten Commit hinzugefügt.
   * Remote-Repository: Nicht konfiguriert. Es gibt keinen Remote-Origin, daher ist es unmöglich, Updates abzurufen oder Branches zu vergleichen.
   * Große Dateien: Es wurden mehrere sehr große Dateien gefunden, hauptsächlich in den Unterverzeichnissen venv und public_repositories. Die größten davon sind
     .lib-Bibliotheken und .zip-Archive. Es wird empfohlen, Pfade, die große Binärdateien (z. B. venv, *.zip) enthalten, zur .gitignore-Datei hinzuzufügen,
     um deren Aufnahme in das Repository zu verhindern.

  Audit abgeschlossen.
```
![17](assets/17.png)


### Szenario: "Docker-Umgebungsbereinigung"

Docker sammelt im Laufe der Zeit viele unnötige Images, Container und Netzwerke an. Dieses Szenario hilft, alles sicher zu bereinigen.

1.  **Erstellen Sie die Datei `docker-cleanup.md`**:

    ```markdown
    Sie sind ein DevOps-Ingenieur, der für die Systemsauberkeit verantwortlich ist. Ihre Aufgabe ist es, die Docker-Umgebung sicher zu bereinigen.
    
    Gehen Sie Schritt für Schritt vor:
    
    1.  **Laufende Container anzeigen:** Zeigen Sie zunächst eine Liste aller aktiven Container an, damit ich sicherstellen kann, dass ich nichts Wichtiges stoppe. Schlagen Sie `!docker ps` vor.
    2.  **Alle Container stoppen:** Schlagen Sie nach meiner Genehmigung einen Befehl vor, um ALLE laufenden Container zu stoppen. Befehl: `!docker stop $(docker ps -q)`.
    3.  **Globale Bereinigung:** Führen Sie nun eine vollständige Systembereinigung von "dangling"-Images, gestoppten Containern, ungenutzten Netzwerken und dem Build-Cache durch. Schlagen Sie den sichersten und effizientesten Befehl `!docker system prune -af` vor.
    4.  **Bericht:** Berichten Sie nach der Ausführung, wie viel Speicherplatz freigegeben wurde, basierend auf der Ausgabe des letzten Befehls.
    ```

2.  **Führen Sie das Szenario in Gemini CLI aus:**

    ```
    > Lesen und Ausführen des Docker-Bereinigungsszenarios aus der Datei 'docker-cleanup.md'
    ```
**Ergebnis:** Gemini wird Sie durch einen sicheren Bereinigungsprozess führen und bei jedem kritischen Schritt eine Bestätigung anfordern.

---


### Szenario: "Starten von Systemanwendungen"

Wie im Beispiel gezeigt, handhabt Gemini das Starten von Anwendungen hervorragend. Formalisieren wir dies in einem einfachen Szenario für Windows.

1.  **Erstellen Sie die Datei `open-windows-tools.md`**:

    ```markdown
    Sie sind ein Windows-Systemadministrator. Ihre Aufgabe ist es, Systemdienstprogramme auf Anfrage zu öffnen.

    - Wenn ich nach "Task-Scheduler" frage, schlagen Sie vor, `!taskschd.msc` zu starten.
    - Wenn ich nach "Registrierungseditor" frage, warnen Sie vor der Gefahr und schlagen Sie vor, `!regedit` zu starten.
    - Wenn ich nach "Ressourcenmonitor" frage, schlagen Sie vor, `!resmon` zu starten.
    - Wenn ich nach "Task-Manager" frage, schlagen Sie vor, `!taskmgr` zu starten.
    - Wenn ich nach "Eingabeaufforderung" frage, schlagen Sie vor, `!cmd` zu starten.
    - Wenn ich nach "Explorer" frage, schlagen Sie vor, `!explorer` zu starten.
    Ähnlich für andere Dienstprogramme.
    ```

2.  **Führen Sie das Szenario aus und geben Sie den Befehl ein:**

    ```
    > Verwenden Sie Anweisungen aus 'open-windows-tools.md'. Öffnen Sie den Task-Scheduler.
    ```
**Ergebnis:** Gemini wird den Kontext aus der Datei und Ihre Anfrage verstehen und dann vorschlagen, den erforderlichen Befehl auszuführen.

> **Antwort von Gemini:**
> ```text
> Okay, öffne den Task-Scheduler.
>
> Ausführen `!taskschd.msc`? (j/n)
> ```
Nach Bestätigung wird das Standard-Windows-Dienstprogramm auf Ihrem Bildschirm geöffnet.

```