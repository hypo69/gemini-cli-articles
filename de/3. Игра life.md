### **Szenario f√ºr Gemini CLI: Spiel "Leben"**

#### **Schritt 1: Erstellen einer Systemanweisung `GEMINI.md`**

Erstellen Sie ein `.gemini`-Verzeichnis im Arbeitsordner des Projekts. Erstellen Sie innerhalb von `.gemini` eine Datei `GEMINI.md` und f√ºgen Sie die Systemanweisung ein. Beispielanweisung:

````markdown
## üìò Anweisung zur Generierung von Python-Code

### 1. Allgemeine Regeln

* Verwenden Sie **Python 3.10+**.
* Halten Sie sich an einen **klaren, lesbaren und eindeutigen Codierungsstil**.
* **Jede Funktion, Methode und Klasse** muss Folgendes haben:

  * Typannotationen (`type hints`)
  * Vollst√§ndige und korrekte Dokumentation im `docstring`-Format (siehe Abschnitt 3)
  * Interne Kommentare (`#`), wo n√∂tig

---

### 2. Kommentare

* Kommentare m√ºssen **genau** sein und beschreiben, **was der Code tut**, nicht ‚Äûwas wir tun‚Äú.
* **Verboten** ist die Verwendung von Pronomen: `wir tun`, `wir geben zur√ºck`, `wir senden`, `wir gehen` usw.
* **Erlaubt** sind nur Begriffe: `Extraktion`, `Ausf√ºhrung`, `Aufruf`, `Ersetzung`, `Pr√ºfung`, `Senden`, `Funktion f√ºhrt aus`, `Funktion √§ndert Wert` usw.

#### ‚ùå Beispiel f√ºr einen falschen Kommentar:

<pre>```python
# Parameterwert abrufen
````

#### ‚úÖ Beispiel f√ºr einen korrekten Kommentar:

<pre>```python
# Funktion extrahiert Parameterwert
```

---

### 3. Docstring (Dokumentationsformat)

Jede Funktion/Methode/Klasse muss einen `docstring` im folgenden Format enthalten:

<pre>```python
def function(param: str, param1: Optional[str | dict | str] = None) -> dict | None:
    """
    Args:
        param (str): Beschreibung des Parameters `param`.
        param1 (Optional[str | dict | str], optional): Beschreibung des Parameters `param1`. Standardwert `None`.

    Returns:
        dict | None: Beschreibung des R√ºckgabewerts. Gibt ein W√∂rterbuch oder `None` zur√ºck.

    Raises:
        SomeError: Beschreibung der Situation, in der die `SomeError`-Ausnahme auftritt.

    Example:
        >>> function('param', 'param1')
        {'param': 'param1'}
    """
```

* **Alle Parameter und R√ºckgabewerte m√ºssen beschrieben werden.**
* Formulierungen m√ºssen **pr√§gnant, genau und eindeutig** sein.
* Das √úberspringen von Beschreibungen von Parametern/R√ºckgabewerten/Ausnahmen ist nicht zul√§ssig.

---

### 4. Typannotationen

* **Alle Variablen, Parameter und R√ºckgabewerte** m√ºssen annotiert werden.
* Verwenden Sie die Python 3.10+-Syntax: `list[int]`, `dict[str, Any]`, `str | None` usw.
* Beispiele f√ºr korrekte Annotationen:

#### ‚úÖ Einfache Typen:

<pre>```python
name: str = "John"
count: int = 42
flag: bool = True
```

#### ‚úÖ Sammlungen und komplexe Typen:

<pre>```python
from typing import Any, Optional, Callable, TypeAlias

coordinates: tuple[float, float] = (55.75, 37.61)
metadata: dict[str, Any] = {"debug": True}
UserId: TypeAlias = int
```

#### ‚úÖ Funktionen und Methoden:

<pre>```python
def get_user_name(user_id: int) -> str:
    """Gibt den Benutzernamen anhand seiner ID zur√ºck."""
    ...
```

#### ‚úÖ Asynchrone Funktionen:

<pre>```python
async def fetch_users() -> AsyncIterator[dict[str, int | str]]:
    ...
```

#### ‚úÖ Generische Typen:

<pre>```python
from typing import TypeVar, Generic

T = TypeVar("T")

class Container(Generic[T]):
    def __init__(self, value: T) -> None:
        self.value = value

    def get(self) -> T:
        return self.value
```

---

### 5. Sonstiges

* Verwenden Sie `default_factory` in `dataclass` f√ºr ver√§nderliche Werte (`list`, `dict`).
* F√ºr `Optional`-Werte geben Sie `T | None` (Python 3.10+) oder `Optional[T]` an.
* F√ºr komplexe Strukturen ‚Äî verwenden Sie `TypeAlias`.

---

üìå **Tipp:** Das Speichern von `GEMINI.md` in `.gemini` ist eine Standardpraxis f√ºr gemini-cli. Beim Generieren von Code sollten Sie immer Typannotationen und `docstring` einschlie√üen und subjektive Formulierungen in Kommentaren vermeiden. Ziel ist eine m√∂glichst pr√§zise, reproduzierbare und formalisierte Code-Struktur.

---

Der Einfachheit halber erstellen wir ein `game`-Verzeichnis, in dem die Projektdateien gespeichert werden, und ein `scenarios`-Verzeichnis, in dem die Szenarien f√ºr Gemini CLI gespeichert werden:

* `scenarios/life-create-code.md` ‚Äî Anweisungen zum Erstellen des Codes f√ºr das Spiel "Leben"
* `scenarios/life-create-test.md` ‚Äî Anweisungen zum Erstellen von Tests
* `scenarios/life-create-doc.md` ‚Äî Anweisungen zum Erstellen von Dokumentation

---

### **life-create-code.md**

```markdown
Erstellen Sie im Verzeichnis `game` die Datei life.py.
Implementieren Sie Conways "Spiel des Lebens" in Python, unter Verwendung eines objektorientierten Ansatzes.
Verwenden Sie Bibliotheken: `numpy`, `pygame` (f√ºr Grafiken).

Anforderungen:
1.  Erstellen Sie eine `Game`-Klasse.
2.  In `__init__` sollte die Klasse Gitterdimensionen (Breite, H√∂he) annehmen und ein zuf√§lliges Anfangsfeld erstellen.
3.  Erstellen Sie eine `step()`-Methode, die den Spielzustand um einen Schritt aktualisiert:
    - Eine lebende Zelle mit < 2 lebenden Nachbarn stirbt (Unterbev√∂lkerung).
    - Eine lebende Zelle mit 2 oder 3 lebenden Nachbarn √ºberlebt.
    - Eine lebende Zelle mit > 3 lebenden Nachbarn stirbt (√úberbev√∂lkerung).
    - Eine tote Zelle mit genau 3 lebenden Nachbarn wird lebendig (Reproduktion).
4.  Erstellen Sie eine `display()`-Methode oder √ºberschreiben Sie `__str__`, um das Feld in der Konsole auszugeben ('‚ñ†' f√ºr eine lebende Zelle, ' ' f√ºr eine tote).
5.  Verwenden Sie `numpy` f√ºr effiziente Gitteroperationen.
6.  F√ºgen Sie im `if __name__ == '__main__':`-Block ein Beispiel hinzu, das ein Spiel erstellt und die Simulation mit einer kleinen Verz√∂gerung zwischen den Schritten ausf√ºhrt.
7. Verwenden Sie pygame oder eine andere Grafikbibliothek zur Spielvisualisierung.
```

---

### **life-create-test.md**

```markdown
Erstellen Sie im Verzeichnis `game` die Datei test_life.py, unter Verwendung des Kontexts aus der Datei @life.py. Verwenden Sie das pytest-Framework.

Der Test sollte die Evolution eines einfachen "Blinker"-Oszillators √ºberpr√ºfen:

1. Importieren Sie die `Game`-Klasse aus `life`.
2. Erstellen Sie eine Testfunktion, zum Beispiel `test_blinker_oscillation`.
3. Erstellen Sie eine `Game`-Instanz mit einer festen Gr√∂√üe (z. B. 5x5).
4. Legen Sie den Anfangszustand des Feldes manuell fest: eine horizontale Linie aus drei lebenden Zellen in der Mitte.
5. Rufen Sie `game.step()` auf.
6. √úberpr√ºfen Sie mit `assert` und `numpy.array_equal`, ob sich das Feld in eine vertikale Linie aus drei Zellen ge√§ndert hat.
7. Rufen Sie `game.step()` erneut auf.
8. √úberpr√ºfen Sie, ob das Feld in seinen urspr√ºnglichen horizontalen Zustand zur√ºckgekehrt ist.
```

---

### **life-create-doc.md**

```markdown
Analysieren Sie die Dateien @life.py und @test_life.py im Verzeichnis `game` und erstellen Sie auf deren Grundlage eine Dokumentationsdatei doc.md.

Dokumentationsstruktur:
- **Titel:** # Projekt "Spiel des Lebens"
- **Kurzbeschreibung:** Implementierung von Conways zellul√§rem Automaten.
- **Dateistruktur:** Kurze Beschreibung des Zwecks der Dateien `life.py` und `test_life.py`.
- **So starten Sie die Simulation:** Befehl zum Ausf√ºhren der Hauptdatei (`python life.py`).
- **So f√ºhren Sie Tests aus:** Befehle zur Installation von Abh√§ngigkeiten (`pip install pytest numpy`) und zum Ausf√ºhren von Tests (`pytest`).
```

---

### **Schritt 2: Erstellen des Codes f√ºr das Spiel "Leben"**

Starten Sie gemini-cli im Terminal. Wichtig! Stellen Sie sicher, dass Sie sich in dem Verzeichnis befinden, in dem sich `.gemini/GEMINI.md` befindet.

1. Erteilen Sie die Berechtigung zum Erstellen der Datei.
2. Gemini CLI generiert die Datei `life.py` im Verzeichnis `game`.
3. Erstellen Sie eine virtuelle Umgebung (venv), installieren Sie Abh√§ngigkeiten und starten Sie das Spiel.

---

### **Schritt 3: Erstellen von Tests**

1. Gemini CLI generiert die Datei `test_life.py` im Verzeichnis `game`.
2. Testen Sie einfache Szenarien, wie den "Blinker"-Oszillator.
3. Korrigieren Sie Fehler bei Bedarf.

---

### **Schritt 4: Erstellen der Dokumentation**

1. Gemini CLI analysiert `life.py` und `test_life.py`.
2. Generiert eine `doc.md`-Datei mit einer Projektbeschreibung, Anweisungen zum Starten des Spiels und der Tests.

Voila! Das Projekt ist bereit.
