<h3><strong>Scenario for Gemini CLI: Game of Life</strong></h3>
<h4><strong>Step 1: Creating a system instruction <code>GEMINI.md</code></strong></h4>
<p>Create a <code>.gemini</code> directory in the project's working folder. Inside <code>.gemini</code>, create a <code>GEMINI.md</code> file and insert the system instruction into it. Example instruction:</p>
<pre class="line-numbers"><code class="language-markdown">## üìò Instructions for Python Code Generation

### 1. General Rules

* Use **Python 3.10+**.
* Adhere to a **clear, readable, and unambiguous coding style**.
* **Every function, method, and class** must have:

  * Type annotations (`type hints`)
  * Full and correct documentation in `docstring` format (see section 3)
  * Internal comments (`#`), where necessary

---

### 2. Comments

* Comments must be **accurate** and describe **what the code does**, not "what we are doing".
* **Forbidden** to use pronouns: `we do`, `we return`, `we send`, `we go`, etc.
* **Allowed** only terms: `extraction`, `execution`, `call`, `replacement`, `check`, `sending`, `Function performs`, `Function changes value`, etc.

#### ‚ùå Example of incorrect comment:

<pre>```python
# Get parameter value
````

#### ‚úÖ Example of correct comment:

<pre>```python
# Function extracts parameter value
```

---

### 3. Docstring (documentation format)

Each function/method/class must contain a `docstring` in the following format:

<pre>```python
def function(param: str, param1: Optional[str | dict | str] = None) -> dict | None:
    """
    Args:
        param (str): Description of parameter `param`.
        param1 (Optional[str | dict | str], optional): Description of parameter `param1`. Defaults to `None`.

    Returns:
        dict | None: Description of the return value. Returns a dictionary or `None`.

    Raises:
        SomeError: Description of the situation in which the `SomeError` exception occurs.

    Example:
        >>> function('param', 'param1')
        {'param': 'param1'}
    """
```

* **All parameters and return values must be described.**
* Formulations must be **concise, accurate, and unambiguous**.
* Skipping descriptions of parameters/return values/exceptions is not allowed.

---

### 4. Type Annotations

* **All variables, parameters, and return values** must be annotated.
* Use Python 3.10+ syntax: `list[int]`, `dict[str, Any]`, `str | None`, etc.
* Examples of correct annotations:

#### ‚úÖ Simple types:

<pre>```python
name: str = "John"
count: int = 42
flag: bool = True
```

#### ‚úÖ Collections and complex types:

<pre>```python
from typing import Any, Optional, Callable, TypeAlias

coordinates: tuple[float, float] = (55.75, 37.61)
metadata: dict[str, Any] = {"debug": True}
UserId: TypeAlias = int
```

#### ‚úÖ Functions and methods:

<pre>```python
def get_user_name(user_id: int) -> str:
    """Returns the user's name by their ID."""
    ...
```

#### ‚úÖ Asynchronous functions:

<pre>```python
async def fetch_users() -> AsyncIterator[dict[str, int | str]]:
    ...
```

#### ‚úÖ Generic types:

<pre>```python
from typing import TypeVar, Generic

T = TypeVar("T")

class Container(Generic[T]):
    def __init__(self, value: T) -> None:
        self.value = value

    def get(self) -> T:
        return self.value
```

---

### 5. Other

* Use `default_factory` in `dataclass` for mutable values (`list`, `dict`).
* For `Optional` values, specify `T | None` (Python 3.10+) or `Optional[T]`.
* For complex structures ‚Äî use `TypeAlias`.

---

üìå **Hint:** Storing `GEMINI.md` in `.gemini` is standard practice for gemini-cli. When generating code, always include type annotations, `docstring`, and avoid subjective phrasing in comments. The goal is a maximally precise, reproducible, and formalized code structure.
</code></pre>
<hr>
<p>For convenience, let's create a <code>game</code> directory to store project files, and a <code>scenarios</code> directory to store scenarios for Gemini CLI:</p>
<ul>
<li><code>scenarios/life-create-code.md</code> ‚Äî instructions for creating the "Game of Life" code</li>
<li><code>scenarios/life-create-test.md</code> ‚Äî instructions for creating tests</li>
<li><code>scenarios/life-create-doc.md</code> ‚Äî instructions for creating documentation</li>
</ul>
<hr>
<h3><strong>life-create-code.md</strong></h3>
<pre class="line-numbers"><code class="language-markdown">Inside the `game` directory, create the file life.py.
Implement Conway's "Game of Life" in Python, using an object-oriented approach.
Use libraries: `numpy`, `pygame` (for graphics).

Requirements:
1.  Create a `Game` class.
2.  In `__init__`, the class should take grid dimensions (width, height) and create a random initial field.
3.  Create a `step()` method that updates the game state by one step according to the rules:
    - A living cell with &lt; 2 living neighbors dies (underpopulation).
    - A living cell with 2 or 3 living neighbors survives.
    - A living cell with &gt; 3 living neighbors dies (overpopulation).
    - A dead cell with exactly 3 living neighbors becomes alive (reproduction).
4.  Create a `display()` method or override `__str__` to output the field to the console ('‚ñ†' for a living cell, ' ' for a dead one).
5.  Use `numpy` for efficient grid operations.
6.  In the `if __name__ == '__main__':` block, add an example that creates a game and runs the simulation with a small delay between steps.
7. Use pygame or another graphics library for game visualization.
</code></pre>
<hr>
<h3><strong>life-create-test.md</strong></h3>
<pre class="line-numbers"><code class="language-markdown">Inside the `game` directory, create the file test_life.py, using the context from the @life.py file. Use the pytest framework.

The test should check the evolution of a simple "Blinker" oscillator:

1. Import the `Game` class from `life`.
2. Create a test function, for example `test_blinker_oscillation`.
3. Create a `Game` instance with a fixed size (e.g., 5x5).
4. Manually set the initial state of the field: a horizontal line of three living cells in the center.
5. Call `game.step()`.
6. Using `assert` and `numpy.array_equal`, check that the field has changed to a vertical line of three cells.
7. Call `game.step()` again.
8. Check that the field has returned to its original horizontal state.
</code></pre>
<hr>
<h3><strong>life-create-doc.md</strong></h3>
<pre class="line-numbers"><code class="language-markdown">Analyze the files @life.py and @test_life.py inside the `game` directory and create a documentation file doc.md based on them.

Documentation structure:
- **Title:** # Project "Game of Life"
- **Brief description:** Implementation of Conway's cellular automaton.
- **File structure:** Brief description of the purpose of `life.py` and `test_life.py` files.
- **How to run the simulation:** Command to run the main file (`python life.py`).
- **How to run tests:** Commands to install dependencies (`pip install pytest numpy`) and run tests (`pytest`).
</code></pre>
<hr>
<h3><strong>Step 2: Creating the "Game of Life" code</strong></h3>
<p>Launch gemini-cli in the terminal. Important! Make sure you are in the directory where <code>.gemini/GEMINI.md</code> is located.</p>
<ol>
<li>Grant permission to create the file.</li>
<li>Gemini CLI will generate the <code>life.py</code> file in the <code>game</code> directory.</li>
<li>Create a venv virtual environment, install dependencies, and run the game.</li>
</ol>
<hr>
<h3><strong>Step 3: Creating tests</strong></h3>
<ol>
<li>Gemini CLI generates the <code>test_life.py</code> file in the <code>game</code> directory.</li>
<li>Test simple scenarios, such as the "Blinker" oscillator.</li>
<li>Fix errors if necessary.</li>
</ol>
<hr>
<h3><strong>Step 4: Creating documentation</strong></h3>
<ol>
<li>Gemini CLI analyzes <code>life.py</code> and <code>test_life.py</code>.</li>
<li>Generates a <code>doc.md</code> file with a project description, instructions for running the game and tests.</li>
</ol>
<p>Voila! The project is ready.</p>