### **Scenario for Gemini CLI: Game of Life**

#### **Step 1: Creating a system instruction `GEMINI.md`**

Create a `.gemini` directory in the project's working folder. Inside `.gemini`, create a `GEMINI.md` file and insert the system instruction into it. Example instruction:

````markdown
## 📘 Instructions for Python Code Generation

### 1. General Rules

* Use **Python 3.10+**.
* Adhere to a **clear, readable, and unambiguous coding style**.
* **Every function, method, and class** must have:

  * Type annotations (`type hints`)
  * Full and correct documentation in `docstring` format (see section 3)
  * Internal comments (`#`), where necessary

---

### 2. Comments

* Comments must be **accurate** and describe **what the code does**, not "what we are doing".
* **Forbidden** to use pronouns: `we do`, `we return`, `we send`, `we go`, etc.
* **Allowed** only terms: `extraction`, `execution`, `call`, `replacement`, `check`, `sending`, `Function performs`, `Function changes value`, etc.

#### ❌ Example of incorrect comment:

```python
# Get parameter value
````

#### ✅ Example of correct comment:

```python
# Function extracts parameter value
```

---

### 3. Docstring (documentation format)

Each function/method/class must contain a `docstring` in the following format:

```python
def function(param: str, param1: Optional[str | dict | str] = None) -> dict | None:
    """
    Args:
        param (str): Description of parameter `param`.
        param1 (Optional[str | dict | str], optional): Description of parameter `param1`. Defaults to `None`.

    Returns:
        dict | None: Description of the return value. Returns a dictionary or `None`.

    Raises:
        SomeError: Description of the situation in which the `SomeError` exception occurs.

    Example:
        >>> function('param', 'param1')
        {'param': 'param1'}
    """
```

* **All parameters and return values must be described.**
* Formulations must be **concise, accurate, and unambiguous**.
* Skipping descriptions of parameters/return values/exceptions is not allowed.

---

### 4. Type Annotations

* **All variables, parameters, and return values** must be annotated.
* Use Python 3.10+ syntax: `list[int]`, `dict[str, Any]`, `str | None`, etc.
* Examples of correct annotations:

#### ✅ Simple types:

```python
name: str = "John"
count: int = 42
flag: bool = True
```

#### ✅ Collections and complex types:

```python
from typing import Any, Optional, Callable, TypeAlias

coordinates: tuple[float, float] = (55.75, 37.61)
metadata: dict[str, Any] = {"debug": True}
UserId: TypeAlias = int
```

#### ✅ Functions and methods:

```python
def get_user_name(user_id: int) -> str:
    """Returns the user's name by their ID."""
    ...
```

#### ✅ Asynchronous functions:

```python
async def fetch_users() -> AsyncIterator[dict[str, int | str]]:
    ...
```

#### ✅ Generic types:

```python
from typing import TypeVar, Generic

T = TypeVar("T")

class Container(Generic[T]):
    def __init__(self, value: T) -> None:
        self.value = value

    def get(self) -> T:
        return self.value
```

---

### 5. Other

* Use `default_factory` in `dataclass` for mutable values (`list`, `dict`).
* For `Optional` values, specify `T | None` (Python 3.10+) or `Optional[T]`.
* For complex structures — use `TypeAlias`.

---

📌 **Hint:** Storing `GEMINI.md` in `.gemini` is standard practice for gemini-cli. When generating code, always include type annotations, `docstring`, and avoid subjective phrasing in comments. The goal is a maximally precise, reproducible, and formalized code structure.

---

For convenience, let's create a `game` directory to store project files, and a `scenarios` directory to store scenarios for Gemini CLI:

* `scenarios/life-create-code.md` — instructions for creating the "Game of Life" code
* `scenarios/life-create-test.md` — instructions for creating tests
* `scenarios/life-create-doc.md` — instructions for creating documentation

---

### **life-create-code.md**

```markdown
Inside the `game` directory, create the file life.py.
Implement Conway's "Game of Life" in Python, using an object-oriented approach.
Use libraries: `numpy`, `pygame` (for graphics).

Requirements:
1.  Create a `Game` class.
2.  In `__init__`, the class should take grid dimensions (width, height) and create a random initial field.
3.  Create a `step()` method that updates the game state by one step according to the rules:
    - A living cell with < 2 living neighbors dies (underpopulation).
    - A living cell with 2 or 3 living neighbors survives.
    - A living cell with > 3 living neighbors dies (overpopulation).
    - A dead cell with exactly 3 living neighbors becomes alive (reproduction).
4.  Create a `display()` method or override `__str__` to output the field to the console ('■' for a living cell, ' ' for a dead one).
5.  Use `numpy` for efficient grid operations.
6.  In the `if __name__ == '__main__':` block, add an example that creates a game and runs the simulation with a small delay between steps.
7. Use pygame or another graphics library for game visualization.
```

---

### **life-create-test.md**

```markdown
Inside the `game` directory, create the file test_life.py, using the context from the @life.py file. Use the pytest framework.

The test should check the evolution of a simple "Blinker" oscillator:

1. Import the `Game` class from `life`.
2. Create a test function, for example `test_blinker_oscillation`.
3. Create a `Game` instance with a fixed size (e.g., 5x5).
4. Manually set the initial state of the field: a horizontal line of three living cells in the center.
5. Call `game.step()`.
6. Using `assert` and `numpy.array_equal`, check that the field has changed to a vertical line of three cells.
7. Call `game.step()` again.
8. Check that the field has returned to its original horizontal state.
```

---

### **life-create-doc.md**

```markdown
Analyze the files @life.py and @test_life.py inside the `game` directory and create a documentation file doc.md based on them.

Documentation structure:
- **Title:** # Project "Game of Life"
- **Brief description:** Implementation of Conway's cellular automaton.
- **File structure:** Brief description of the purpose of `life.py` and `test_life.py` files.
- **How to run the simulation:** Command to run the main file (`python life.py`).
- **How to run tests:** Commands to install dependencies (`pip install pytest numpy`) and run tests (`pytest`).
```

---

### **Step 2: Creating the "Game of Life" code**

Launch gemini-cli in the terminal. Important! Make sure you are in the directory where `.gemini/GEMINI.md` is located.

1. Grant permission to create the file.
2. Gemini CLI will generate the `life.py` file in the `game` directory.
3. Create a venv virtual environment, install dependencies, and run the game.

---

### **Step 3: Creating tests**

1. Gemini CLI generates the `test_life.py` file in the `game` directory.
2. Test simple scenarios, such as the "Blinker" oscillator.
3. Fix errors if necessary.

---

### **Step 4: Creating documentation**

1. Gemini CLI analyzes `life.py` and `test_life.py`.
2. Generates a `doc.md` file with a project description, instructions for running the game and tests.

Voila! The project is ready.