### **Escenario para Gemini CLI: Juego "Vida"**

#### **Paso 1: Creaci√≥n de la instrucci√≥n del sistema `GEMINI.md`**

Cree el directorio `.gemini` en la carpeta de trabajo del proyecto. Dentro de `.gemini`, cree el archivo `GEMINI.md` e inserte la instrucci√≥n del sistema. Ejemplo de instrucci√≥n:

````markdown
## üìò Instrucci√≥n para la generaci√≥n de c√≥digo Python

### 1. Reglas generales

* Utiliza **Python 3.10+**.
* Sigue un **estilo de codificaci√≥n claro, legible e inequ√≠voco**.
* **Cada funci√≥n, m√©todo y clase** debe tener:

  * Anotaci√≥n de tipos (`type hints`)
  * Documentaci√≥n completa y correcta en formato `docstring` (ver secci√≥n 3)
  * Comentarios internos (`#`), donde sea necesario

---

### 2. Comentarios

* Los comentarios deben ser **precisos** y describir **qu√© hace el c√≥digo**, no ¬´qu√© hacemos¬ª.
* **Prohibido** usar pronombres: `hacemos`, `devolvemos`, `enviamos`, `pasamos`, etc.
* **Permitidos** solo t√©rminos: `extracci√≥n`, `ejecuci√≥n`, `llamada`, `reemplazo`, `verificaci√≥n`, `env√≠o`, `La funci√≥n realiza`, `La funci√≥n modifica el valor`, etc.

#### ‚ùå Ejemplo de comentario incorrecto:

```python
# Obtenemos el valor del par√°metro
````

#### ‚úÖ Ejemplo de comentario correcto:

```python
# La funci√≥n extrae el valor del par√°metro
```

---

### 3. Docstring (formato de documentaci√≥n)

Cada funci√≥n/m√©todo/clase debe contener `docstring` en el siguiente formato:

```python
def function(param: str, param1: Optional[str | dict | str] = None) -> dict | None:
    """
    Args:
        param (str): Descripci√≥n del par√°metro `param`.
        param1 (Optional[str | dict | str], optional): Descripci√≥n del par√°metro `param1`. Por defecto `None`.

    Returns:
        dict | None: Descripci√≥n del valor de retorno. Devuelve un diccionario o `None`.

    Raises:
        SomeError: Descripci√≥n de la situaci√≥n en la que se produce la excepci√≥n `SomeError`.

    Example:
        >>> function('param', 'param1')
        {'param': 'param1'}
    """
```

* **Todos los par√°metros y valores de retorno deben estar descritos.**
* Las formulaciones deben ser **concisas, precisas e inequ√≠vocas**.
* No se permite omitir la descripci√≥n de par√°metros/valores de retorno/excepciones.

---

### 4. Anotaci√≥n de tipos

* **Todas las variables, par√°metros y valores de retorno** deben estar anotados.
* Utiliza la sintaxis de Python 3.10+: `list[int]`, `dict[str, Any]`, `str | None`, etc.
* Ejemplos de anotaciones correctas:

#### ‚úÖ Tipos simples:

```python
name: str = "John"
count: int = 42
flag: bool = True
```

#### ‚úÖ Colecciones y tipos complejos:

```python
from typing import Any, Optional, Callable, TypeAlias

coordinates: tuple[float, float] = (55.75, 37.61)
metadata: dict[str, Any] = {"debug": True}
UserId: TypeAlias = int
```

#### ‚úÖ Funciones y m√©todos:

```python
def get_user_name(user_id: int) -> str:
    """Devuelve el nombre de usuario por su identificador."""
    ...
```

#### ‚úÖ Funciones as√≠ncronas:

```python
async def fetch_users() -> AsyncIterator[dict[str, int | str]]:
    ...
```

#### ‚úÖ Tipos gen√©ricos:

```python
from typing import TypeVar, Generic

T = TypeVar("T")

class Container(Generic[T]):
    def __init__(self, value: T) -> None:
        self.value = value

    def get(self) -> T:
        return self.value
```

---

### 5. Otros

* Utiliza `default_factory` en `dataclass` para valores mutables (`list`, `dict`).
* Para valores `Optional`, especifica `T | None` (Python 3.10+) u `Optional[T]`.
* Para estructuras complejas, utiliza `TypeAlias`.

---

üìå **Sugerencia:** Almacenar `GEMINI.md` en `.gemini` es una pr√°ctica est√°ndar para gemini-cli. Al generar c√≥digo, incluye siempre la anotaci√≥n de tipos, `docstring` y evita formulaciones subjetivas en los comentarios. El objetivo es una estructura de c√≥digo lo m√°s precisa, reproducible y formalizada posible.

---

Para mayor comodidad, crearemos un directorio `game`, donde se almacenar√°n los archivos del proyecto, y un directorio `scenarios`, donde se almacenar√°n los escenarios para Gemini CLI:

* `scenarios/life-create-code.md` ‚Äî instrucciones para crear el c√≥digo del juego "Vida"
* `scenarios/life-create-test.md` ‚Äî instrucciones para crear pruebas
* `scenarios/life-create-doc.md` ‚Äî instrucciones para crear documentaci√≥n

---

### **life-create-code.md**

```markdown
Dentro del directorio `game`, crea el archivo life.py. 
Implementa el "Juego de la Vida" de Conway en Python, utilizando un enfoque orientado a objetos.
Utiliza las bibliotecas: `numpy`, `pygame` (para gr√°ficos).

Requisitos:
1.  Crea la clase `Game`.
2.  En `__init__`, la clase debe aceptar las dimensiones de la cuadr√≠cula (ancho, alto) y crear un campo inicial aleatorio.
3.  Crea el m√©todo `step()`, que actualiza el estado del juego en un paso:
    - Una c√©lula viva con < 2 vecinos vivos muere (soledad).
    - Una c√©lula viva con 2 o 3 vecinos vivos sobrevive.
    - Una c√©lula viva con > 3 vecinos vivos muere (superpoblaci√≥n).
    - Una c√©lula muerta con exactamente 3 vecinos vivos se vuelve viva (nacimiento).
4.  Crea el m√©todo `display()` o anula `__str__` para mostrar el campo en la consola ('‚ñ†' para c√©lula viva, ' ' para c√©lula muerta).
5.  Utiliza `numpy` para trabajar eficientemente con la cuadr√≠cula.
6.  En el bloque `if __name__ == '__main__':` agrega un ejemplo que cree el juego y ejecute la simulaci√≥n con un peque√±o retraso entre pasos.
7. Para la visualizaci√≥n del juego, utiliza `pygame` u otra biblioteca gr√°fica.
```

---

### **life-create-test.md**

```markdown
Dentro del directorio `game`, crea el archivo test_life.py, utilizando el contexto del archivo @life.py. Utiliza el framework pytest.

El test debe verificar la evoluci√≥n de un oscilador simple "Blinker":

1. Importa la clase `Game` de `life`.
2. Crea una funci√≥n de test, por ejemplo `test_blinker_oscillation`.
3. Crea una instancia de `Game` con un tama√±o fijo (por ejemplo, 5x5).
4. Establece manualmente el estado inicial del campo: una l√≠nea horizontal de tres c√©lulas vivas en el centro.
5. Llama a `game.step()`.
6. Con `assert` y `numpy.array_equal`, verifica que el campo haya cambiado a una l√≠nea vertical de tres c√©lulas.
7. Llama a `game.step()` una vez m√°s.
8. Verifica que el campo haya vuelto a su estado horizontal original.
```

---

### **life-create-doc.md**

```markdown
Analiza los archivos @life.py y @test_life.py dentro del directorio `game` y, bas√°ndote en ellos, crea el archivo de documentaci√≥n doc.md.

Estructura de la documentaci√≥n:
- **T√≠tulo:** # Proyecto "Juego de la Vida"
- **Breve descripci√≥n:** Implementaci√≥n del aut√≥mata celular de Conway.
- **Estructura de archivos:** Breve descripci√≥n del prop√≥sito de los archivos `life.py` y `test_life.py`.
- **C√≥mo iniciar la simulaci√≥n:** Comando para ejecutar el archivo principal (`python life.py`).
- **C√≥mo ejecutar las pruebas:** Comandos para instalar dependencias (`pip install pytest numpy`) y ejecutar pruebas (`pytest`).
```

---

### **Paso 2: Creaci√≥n del c√≥digo del juego "Vida"**

Ejecutamos gemini-cli en el terminal. ¬°Importante! Aseg√∫rate de estar en el directorio donde se encuentra `.gemini/GEMINI.md`.

1. Damos permiso para crear el archivo.
2. Gemini CLI generar√° el archivo `life.py` en el directorio `game`.
3. Creamos un entorno virtual venv, instalamos las dependencias y ejecutamos el juego.

---

### **Paso 3: Creaci√≥n de pruebas**

1. Gemini CLI genera el archivo `test_life.py` en el directorio `game`.
2. Probamos escenarios simples, por ejemplo, el oscilador "Blinker".
3. Corregimos errores si es necesario.

---

### **Paso 4: Creaci√≥n de documentaci√≥n**

1. Gemini CLI analiza `life.py` y `test_life.py`.
2. Genera el archivo `doc.md` con la descripci√≥n del proyecto, instrucciones para iniciar el juego y las pruebas.

¬°Voil√°! El proyecto est√° listo.