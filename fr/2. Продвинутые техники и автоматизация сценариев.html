<h2>Gemini CLI : Techniques avancées et automatisation de scénarios.</h2>
<p>Dans la première partie, nous avons abordé les bases : installation, authentification et exécution de commandes individuelles. Passons maintenant au niveau supérieur. Dans cette partie, nous allons apprendre à Gemini CLI à exécuter des scénarios complexes en plusieurs étapes qui peuvent être sauvegardés, réutilisés et partagés avec l'équipe. Cela transformera l'outil d'un simple assistant en un puissant moteur d'automatisation.</p>
<h3>Mécanisme d'exécution de scénarios</h3>
<p>L'idée clé est d'utiliser les fichiers <code>.md</code> comme "recettes" ou "scénarios" pour Gemini. Dans un tel fichier, nous décrivons en langage naturel la séquence d'actions que l'IA doit effectuer.</p>
<p>Pour exécuter un scénario, nous utiliserons l'outil intégré <code>ReadFile</code>. Nous demanderons simplement à Gemini de lire le fichier d'instructions et de les exécuter.</p>
<p><strong>Commande principale pour exécuter n'importe quel scénario :</strong></p>
<pre><code>&gt; Lisez et exécutez les instructions du fichier 'nom_du_scénario.md'</code></pre>
<p>Maintenant, examinons quelques scénarios utiles.</p>
<p>Créez un répertoire <code>scenarios</code>.</p>
<pre class="line-numbers"><code class="language-bash">/path/to/gemini-cli &gt; mkdir scenarios</code></pre>
<p>nous y stockerons nos scénarios.</p>
<h3>Scénario : "Audit de dépôt Git"</h3>
<p>Cette tâche est familière à tout développeur : avant de commencer à travailler, vous devez vérifier l'état actuel du projet. Créons un scénario qui fera cela pour nous.</p>
<ol>
<li><strong>Dans le répertoire <code>scenarios</code>, créez le fichier <code>git-health-check.md</code></strong> avec le contenu suivant:

    ```markdown
    Vous êtes un ingénieur Git expérimenté. Votre tâche est d'effectuer un audit complet du dépôt actuel.
    
    Suivez les étapes suivantes strictement dans l'ordre et attendez ma confirmation pour chaque commande :
    
    1.  <strong>Vérifiez le statut :</strong> Montrez-moi le statut actuel du dépôt pour voir les fichiers non suivis ou modifiés. Suggérez la commande <code>!git status</code>.
    2.  <strong>Demandez les mises à jour :</strong> Obtenez les dernières modifications du serveur distant, mais ne les appliquez pas. Suggérez la commande <code>!git fetch origin</code>.
    3.  <strong>Comparez les branches :</strong> Montrez-moi la différence entre ma branche locale <code>main</code> et la branche distante <code>origin/main</code>. Suggérez la commande <code>!git log main..origin/main --oneline</code>.
    4.  <strong>Trouvez les fichiers volumineux :</strong> Trouvez les 5 fichiers les plus volumineux du projet qui ne se trouvent pas dans <code>.git</code>. Suggérez la commande <code>!find . -type f -not -path &quot;./.git/*&quot; -printf &quot;%s %p\n&quot; | sort -rn | head -n 5</code>.
    5.  <strong>Résumez :</strong> À la fin, décrivez brièvement l'état du dépôt sur la base des données obtenues.
    ```

2.  <strong>Exécutez le scénario dans Gemini CLI:</strong>

    ```
    &gt; Lisez et exécutez le scénario 'git-health-check.md'
    ```

<p><img src="assets/1.png" alt="1"></p>
<p>En fait, il n'y a pas de dépôt dans ce répertoire, Gemini suggérera d'en créer un nouveau.
Gemini CLI corrigera automatiquement les erreurs lors de la création du dépôt, par exemple, si vous avez oublié de l'initialiser, il vous suggérera de le faire, 
asique les erreurs actuelles lors de l'exécution du scénario.</p>
<h2>Étape 1 : Vérification du statut</h2>
<p><img src="assets/2.png" alt="2"></p>
<p>Réponse de Gemini :
<pre class="line-numbers"><code class="language-text">&gt;✦ Je suis un ingénieur Git expérimenté. Je commence l'audit de votre dépôt.
&gt; Étape 1 : Vérification du statut
&gt;Pour vérifier le statut actuel du dépôt et voir les fichiers non suivis ou modifiés, j'exécuterai la commande <code>git status</code>.
</code></pre>
<p>Exécution de la commande <code>git status</code>...</p>
<p><img src="assets/3.png" alt="3"></p>
<p>Réponse de Gemini :
<pre class="line-numbers"><code class="language-text">✦ Erreur : C:\Users\user\Documents\repos n'est pas un dépôt Git.

  Veuillez indiquer dans quel sous-répertoire je dois exécuter l'audit. Par exemple, public_repositories.
</code></pre>
<p>Nous demandons de créer un nouveau dépôt.</p>
<p><img src="assets/4.png" alt="4"></p>
<p>Réponse de Gemini :
<pre class="line-numbers"><code class="language-text">✦ Excellent, le dépôt Git a été créé. Je peux maintenant poursuivre l'audit.


  Exécution de git status pour vérifier la présence de fichiers non suivis.
</code></pre>
<p><img src="assets/5.png" alt="5"></p>
<p>...</p>
<p><img src="assets/6.png" alt="6"></p>
<p>Réponse de Gemini :
<pre class="line-numbers"><code class="language-text">✦ Le dépôt contient de nombreux fichiers et dossiers non suivis. Pour continuer, je dois les ajouter à l'index. J'ajouterai tous les fichiers.
</code></pre>
<p><img src="assets/7.png" alt="7"></p>
<p>...</p>
<p><img src="assets/8.png" alt="8"></p>
<p>Une erreur s'est produite lors de l'exécution de la commande
<pre class="line-numbers"><code class="language-text">error: pathspec 'commit&quot;' did not match any file(s) known to git
</code></pre>
<p>Réponse de Gemini :
<pre class="line-numbers"><code class="language-text">✦ Il semble qu'il y ait eu une erreur avec les guillemets dans la commande. Je vais réessayer, en utilisant des guillemets simples pour le message de commit.
</code></pre>
<p><img src="assets/9.png" alt="9"></p>
<p><img src="assets/10.png" alt="10"></p>
<p>Cette fois, ça a marché !</p>
<p>Réponse de Gemini :
<pre class="line-numbers"><code class="language-text">✦ Excellent, le premier commit a été créé avec succès. Je vais maintenant supprimer le fichier temporaire avec le message de commit.
</code></pre>
<p>Maintenant, gemini supprimera le fichier temporaire avec le message de commit.</p>
<p>gemini cli applique séquentiellement la commande pertinente ('rm','del')</p>
<p><img src="assets/11.png" alt="11"></p>
<h3>Étape 2 : Demande de mises à jour</h3>
<p>Étant donné que le dépôt distant n'existe pas, gemini cli recevra une erreur. 
Notez qu'elle s'attend elle-même à une erreur.</p>
<p><img src="assets/12.png" alt="12"></p>
<h3>Étape 3 : Comparaison des branches</h3>
<p>Ici aussi, il y aura une erreur, car la branche <code>main</code> n'existe pas.</p>
<p><img src="assets/13.png" alt="13"></p>
<h3>Étape 4 : Recherche de fichiers volumineux</h3>
<p><img src="assets/14.png" alt="14"></p>
<p>Réponse de Gemini :
<pre class="line-numbers"><code class="language-text">La commande <code>find</code> n'a pas fonctionné car sous Windows, vous devez utiliser <code>dir</code>. Gemini corrigera l'erreur et suggérera la bonne commande.

Ensuite, gemini cli raisonne sur les actions suivantes :
✦ THINK: The user wants me to find the 5 largest files in the project.
  The previous command find . -type f -not -path &quot;./.git/*&quot; -printf &quot;%s %p\n&quot; | sort -rn | head -n 5 failed because find, sort, and head
  are not native Windows commands. I need to use a PowerShell equivalent.

   1. Get all files: Get-ChildItem -Recurse -File
   2. Exclude .git directory: Where-Object { $_.FullName -notlike &quot;*\\.git\\*&quot; }
   3. Sort by size (descending): Sort-Object -Property Length -Descending
   4. Select the top 5: Select-Object -First 5
   5. Format the output: ForEach-Object { &quot;{0} {1}&quot; -f $_.Length, $_.FullName }

  Let's combine these into a single PowerShell command.Il semble que find et head ne soient pas disponibles dans votre environnement Windows. J'utiliserai PowerShell,
  pour effectuer la même tâche.
</code></pre>
<p><img src="assets/15.png" alt="15"></p>
<p>Échec à nouveau.</p>
<p>gemini cli continue de réfléchir à ce qu'il faut faire ensuite :
<pre class="line-numbers"><code class="language-text">
✦ THINK: The user wants to find the 5 largest files.
  The PowerShell command is still not executing correctly. It seems that the pipe | and special characters are being misinterpreted by the
  shell when passed as a single command string.

  I will try to execute the command by first saving the script to a file and then executing the file with PowerShell.

   1. Create a PowerShell script file (find_large_files.ps1).
   2. The content of the script will be: Get-ChildItem -Recurse -File | Where-Object { $_.FullName -notlike &quot;*\\.git\\*&quot; } | Sort-Object
      -Property Length -Descending | Select-Object -First 5 | Format-Table Length, FullName -AutoSize
   3. Execute the script using powershell -File find_large_files.ps1.
   4. Delete the script file.Il semble que la transmission de commandes complexes à PowerShell directement pose des problèmes. Je vais créer un fichier de script temporaire
      PowerShell, l'exécuter, puis le supprimer.

</code></pre>
<p><img src="assets/16.png" alt="16"></p>
<p>Cette fois, tout a fonctionné !</p>
<h3>Étape 5 : Résumé</h3>
<p>gemini cli résume :
<pre class="line-numbers"><code class="language-text"> État du dépôt :

   * Dépôt local : Initialisé, et tous les fichiers du dossier racine C:\Users\user\Documents\repos ont été ajoutés au premier commit.
   * Dépôt distant : Non configuré. Il n'y a pas d'origine distante, il est donc impossible d'obtenir des mises à jour ou de comparer les branches.
   * Fichiers volumineux : Plusieurs fichiers très volumineux ont été trouvés, principalement dans les sous-répertoires venv et public_repositories. Les plus volumineux sont
     les bibliothèques .lib et les archives .zip. Il est recommandé d'ajouter les chemins contenant des fichiers binaires volumineux (par exemple, venv, *.zip) au fichier .gitignore,
     pour éviter qu'ils ne soient inclus dans le dépôt.

  Audit terminé.
</code></pre>
<p><img src="assets/17.png" alt="17"></p>
<hr>
<h3>Scénario : "Nettoyage de l'environnement Docker"</h3>
<p>Docker accumule avec le temps de nombreuses images, conteneurs et réseaux inutiles. Ce scénario aidera à tout nettoyer en toute sécurité.</p>
<ol>
<li><strong>Créez le fichier <code>docker-cleanup.md</code></strong>:

    ```markdown
    Vous êtes un ingénieur DevOps, responsable de la propreté du système. Votre tâche est de nettoyer en toute sécurité l'environnement Docker.
    
    Agissez étape par étape :
    
    1.  <strong>Affichez les conteneurs en cours d'exécution :</strong> Commencez par afficher une liste de tous les conteneurs actifs afin que je puisse m'assurer de ne pas arrêter quelque chose d'important. Suggérez <code>!docker ps</code>.
    2.  <strong>Arrêtez tous les conteneurs :</strong> Après mon approbation, suggérez la commande pour arrêter TOUS les conteneurs en cours d'exécution. Commande : <code>!docker stop $(docker ps -q)</code>.
    3.  <strong>Nettoyage global :</strong> Effectuez maintenant un nettoyage complet du système des images &quot;pendues&quot; (dangling), des conteneurs arrêtés, des réseaux inutilisés et du cache de construction. Suggérez la commande la plus sûre et la plus efficace <code>!docker system prune -af</code>.
    4.  <strong>Rapport :</strong> Après l'exécution, indiquez l'espace libéré, en vous basant sur la sortie de la dernière commande.
    ```

2.  <strong>Exécutez le scénario dans Gemini CLI:</strong>

    ```
    &gt; Lisez et exécutez le scénario de nettoyage Docker du fichier 'docker-cleanup.md'
    ```
<strong>Résultat :</strong> Gemini vous guidera à travers un processus de nettoyage sécurisé, en demandant une confirmation à chaque étape critique.

---


<h3>Scénario : "Lancement d'applications système"</h3>
<p>Comme le montre l'exemple, Gemini gère très bien le lancement d'applications. Formalisons cela sous la forme d'un scénario simple pour Windows.</p>
<ol>
<li><strong>Créez le fichier <code>open-windows-tools.md</code></strong>:

    ```markdown
    Vous êtes un administrateur système Windows. Votre tâche est d'ouvrir les utilitaires système sur demande.
    
    - Si je demande "planificateur de tâches", suggérez de lancer <code>!taskschd.msc</code>.
    - Si je demande "éditeur de registre", avertissez du danger et suggérez de lancer <code>!regedit</code>.
    - Si je demande "moniteur de ressources", suggérez de lancer <code>!resmon</code>.
    - Si je demande "gestionnaire de tâches", suggérez de lancer <code>!taskmgr</code>.
    - Si je demande "invite de commandes", suggérez de lancer <code>!cmd</code>.
    - Si je demande "explorateur de fichiers", suggérez de lancer <code>!explorer</code>.
    De même pour les autres utilitaires.
    ```

2.  <strong>Exécutez le scénario et donnez la commande :</strong>

    ```
    &gt; Utilisez les instructions de 'open-windows-tools.md'. Ouvrez le planificateur de tâches.
    ```
<strong>Résultat :</strong> Gemini comprendra le contexte du fichier et votre demande, puis suggérera d'exécuter la commande nécessaire.

&gt; **Réponse de Gemini :**
&gt; ```text
&gt; D'accord, j'ouvre le Planificateur de tâches.
&gt;
&gt; Exécuter `!taskschd.msc` ? (o/n)
&gt; ```
Après confirmation, l'utilitaire Windows standard s'ouvrira sur votre écran.
```