## Gemini CLI : Techniques avancées et automatisation de scénarios.

Dans la première partie, nous avons abordé les bases : installation, authentification et exécution de commandes uniques. Passons maintenant au niveau supérieur. Dans cette partie, nous allons apprendre à Gemini CLI à exécuter des scénarios complexes et multi-étapes qui peuvent être sauvegardés, réutilisés et partagés avec l'équipe. Cela transformera l'outil d'un simple assistant en un puissant moteur d'automatisation.

### Mécanisme d'exécution des scénarios

L'idée clé est d'utiliser des fichiers `.md` comme "recettes" ou "scénarios" pour Gemini. À l'intérieur d'un tel fichier, nous décrivons en langage naturel la séquence d'actions que l'IA doit effectuer.

Pour exécuter un scénario, nous utiliserons l'outil intégré `ReadFile`. Nous demanderons simplement à Gemini de lire le fichier d'instructions et de les exécuter.

**Commande principale pour exécuter n'importe quel scénario :**
```
> Lire et exécuter les instructions du fichier 'nom_du_scénario.md'
```

Examinons maintenant quelques scénarios utiles.

Créez un répertoire `scenarios`.
```bash
/path/to/gemini-cli > mkdir scenarios
```

nous y stockerons nos scénarios.


### Scénario : "Audit de dépôt Git"

Cette tâche est familière à chaque développeur : avant de commencer le travail, vous devez vérifier l'état actuel du projet. Créons un scénario qui le fera pour nous.

1.  **Dans le répertoire `scenarios`, créez le fichier `git-health-check.md`** avec le contenu suivant :

    ```markdown
    Vous êtes un ingénieur Git expérimenté. Votre tâche est de réaliser un audit complet du dépôt actuel.

    Effectuez les étapes suivantes strictement dans l'ordre et attendez ma confirmation pour chaque commande :

    1.  **Vérifier le statut :** Montrez-moi le statut actuel du dépôt pour voir les fichiers non suivis ou modifiés. Suggérez la commande `!git status`.
    2.  **Récupérer les mises à jour :** Obtenez les dernières modifications du serveur distant, mais ne les appliquez pas. Suggérez la commande `!git fetch origin`.
    3.  **Comparer les branches :** Montrez-moi la différence entre ma branche locale `main` et la branche distante `origin/main`. Suggérez la commande `!git log main..origin/main --oneline`.
    4.  **Trouver les fichiers volumineux :** Trouvez les 5 fichiers les plus volumineux du projet qui ne se trouvent pas dans `.git`. Suggérez la commande `!find . -type f -not -path "./.git/*" -printf "%s %p\n" | sort -rn | head -n 5`.
    5.  **Résumer :** Enfin, décrivez brièvement l'état du dépôt sur la base des données obtenues.
    ```

2.  **Exécutez le scénario dans Gemini CLI :**

    ```
    > Lire et exécuter le scénario 'git-health-check.md'
    ```

![1](assets/1.png)


En fait, il n'y a pas de dépôt dans ce répertoire, Gemini proposera de créer un nouveau dépôt.
Gemini CLI corrigera indépendamment les erreurs lors de la création du dépôt, par exemple, si vous avez oublié de l'initialiser, il proposera de le faire,
asique les erreurs actuelles lors de l'exécution du scénario

## Étape 1 : Vérification du statut

![2](assets/2.png)

Réponse de Gemini :
```text
>✦ Je suis un ingénieur Git expérimenté. Je commence l'audit de votre dépôt.
> Étape 1 : Vérification du statut
>Pour vérifier le statut actuel du dépôt et voir les fichiers non suivis ou modifiés, j'exécuterai la commande `git status`.
```
Exécution de la commande `git status`...
![3](assets/3.png)

Réponse de Gemini :
```text
✦ Erreur : C:\Users\user\Documents\repos n'est pas un dépôt Git.

  Veuillez spécifier dans quel sous-répertoire je dois exécuter l'audit. Par exemple, public_repositories.
```
Nous demandons de créer un nouveau dépôt.
![4](assets/4.png)
Réponse de Gemini :
```text
✦ Excellent, le dépôt Git a été créé. Je peux maintenant continuer l'audit.


  Exécution de git status pour vérifier les fichiers non suivis.
```
![5](assets/5.png)

...

![6](assets/6.png)

Réponse de Gemini :
```text
✦ Il y a de nombreux fichiers et dossiers non suivis dans le dépôt. Pour continuer, je dois les ajouter à l'index. J'ajouterai tous les fichiers.
```

![7](assets/7.png)
...
![8](assets/8.png)

Une erreur s'est produite lors de l'exécution de la commande
```text
error: pathspec 'commit"' did not match any file(s) known to git
```
Réponse de Gemini :
```text
✦ Il semble qu'il y ait eu une erreur de guillemets dans la commande. Je vais réessayer en utilisant des guillemets simples pour le message de commit.
```

![9](assets/9.png)
![10](assets/10.png)
Cette fois, ça a marché !

Réponse de Gemini :
```text
✦ Excellent, le premier commit a été créé avec succès. Je vais maintenant supprimer le fichier temporaire avec le message de commit.
```
Maintenant, gemini supprimera le fichier temporaire avec le message de commit.

gemini cli applique séquentiellement la commande pertinente ('rm','del')

![11](assets/11.png)




### Étape 2 : Récupération des mises à jour
Puisque le dépôt distant n'existe pas, gemini cli obtiendra une erreur.
Notez qu'il s'attend lui-même à une erreur

![12](assets/12.png)

### Étape 3 : Comparaison des branches

Ici aussi, il y aura une erreur, car la branche `main` n'existe pas.
![13](assets/13.png)

###   Étape 4 : Recherche de fichiers volumineux

![14](assets/14.png)
Réponse de Gemini :
```text
La commande `find` n'a pas fonctionné car sous Windows, vous devez utiliser `dir`. Gemini corrigera l'erreur lui-même et suggérera la bonne commande.

Далее gemini cli рассуждает о следующих действиях:
✦ THINK: L'utilisateur veut que je trouve les 5 fichiers les plus volumineux du projet.
  La commande précédente find . -type f -not -path "./.git/*" -printf "%s %p\n" | sort -rn | head -n 5 a échoué car find, sort et head
  ne sont pas des commandes Windows natives. Je dois utiliser un équivalent PowerShell.

   1. Obtenir tous les fichiers : Get-ChildItem -Recurse -File
   2. Exclure le répertoire .git : Where-Object { $_.FullName -notlike "*\\.git\\*" }
   3. Trier par taille (décroissant) : Sort-Object -Property Length -Descending
   4. Sélectionner les 5 premiers : Select-Object -First 5
   5. Formater la sortie : ForEach-Object { "{0} {1}" -f $_.Length, $_.FullName }

  Combinons-les en une seule commande PowerShell. Il semble que find et head ne soient pas disponibles dans votre environnement Windows. J'utiliserai PowerShell,
  pour effectuer la même tâche.
```
![15](assets/15.png)

Échec à nouveau

gemini cli continue de réfléchir à la suite des actions :
Réponse de Gemini :
```text

✦ THINK: L'utilisateur veut trouver les 5 fichiers les plus volumineux.
  La commande PowerShell ne s'exécute toujours pas correctement. Il semble que le pipe | et les caractères spéciaux soient mal interprétés par le
  shell lorsqu'ils sont passés comme une seule chaîne de commande.

  Je vais essayer d'exécuter la commande en enregistrant d'abord le script dans un fichier, puis en exécutant le fichier avec PowerShell.

   1. Créer un fichier de script PowerShell (find_large_files.ps1).
   2. Le contenu du script sera : Get-ChildItem -Recurse -File | Where-Object { $_.FullName -notlike "*\\.git\\*" } | Sort-Object
      -Property Length -Descending | Select-Object -First 5 | Format-Table Length, FullName -AutoSize
   3. Exécuter le script en utilisant powershell -File find_large_files.ps1.
   4. Supprimer le fichier de script. Il semble que le passage de commandes complexes à PowerShell directement pose des problèmes. Je vais créer un fichier de script temporaire
      PowerShell, l'exécuter, puis le supprimer.

```
![16](assets/16.png)

Cette fois, ça a marché !

### Étape 5 : Résumé
gemini cli résume :
```text
 État du dépôt : 

   * Dépôt local : Initialisé, et tous les fichiers du dossier racine C:\Users\user\Documents\repos ont été ajoutés au premier commit.
   * Dépôt distant : Non configuré. Pas d'origine distante, il est donc impossible d'obtenir des mises à jour ou de comparer des branches.
   * Fichiers volumineux : Plusieurs fichiers très volumineux ont été trouvés, principalement dans les sous-répertoires venv et public_repositories. Les plus grands d'entre eux sont
     les bibliothèques .lib et les archives .zip. Il est recommandé d'ajouter les chemins contenant de gros fichiers binaires (par exemple, venv, *.zip) au fichier .gitignore,
     pour éviter qu'ils ne soient inclus dans le dépôt.

  Audit terminé.
```
![17](assets/17.png)


### Scénario : "Nettoyage de l'environnement Docker"

Docker accumule de nombreuses images, conteneurs et réseaux inutiles au fil du temps. Ce scénario aidera à tout nettoyer en toute sécurité.

1.  **Créez le fichier `docker-cleanup.md`** :

    ```markdown
    Vous êtes un ingénieur DevOps responsable de la propreté du système. Votre tâche est de nettoyer en toute sécurité l'environnement Docker.

    Procédez étape par étape :

    1.  **Afficher les conteneurs en cours d'exécution :** Tout d'abord, listez tous les conteneurs actifs afin que je puisse m'assurer de ne rien arrêter d'important. Suggérez `!docker ps`.
    2.  **Arrêter tous les conteneurs :** Après mon approbation, suggérez une commande pour arrêter TOUS les conteneurs en cours d'exécution. Commande : `!docker stop $(docker ps -q)`.
    3.  **Nettoyage global :** Effectuez maintenant un nettoyage complet du système des images "pendantes" (dangling), des conteneurs arrêtés, des réseaux inutilisés et du cache de construction. Suggérez la commande la plus sûre et la plus efficace `!docker system prune -af`.
    4.  **Rapport :** Après l'exécution, indiquez l'espace libéré, en fonction de la sortie de la dernière commande.
    ```

2.  **Exécutez le scénario dans Gemini CLI :**

    ```
    > Lire et exécuter le scénario de nettoyage Docker à partir du fichier 'docker-cleanup.md'
    ```
**Résultat :** Gemini vous guidera à travers un processus de nettoyage sûr, en vous demandant une confirmation à chaque étape critique.

---


### Scénario : "Lancement d'applications système"

Comme le montre l'exemple, Gemini gère parfaitement le lancement d'applications. Formalisons cela en un scénario simple pour Windows.

1.  **Créez le fichier `open-windows-tools.md`** :

    ```markdown
    Vous êtes un administrateur système Windows. Votre tâche est d'ouvrir les utilitaires système sur demande.

    - Si je demande "planificateur de tâches", suggérez de lancer `!taskschd.msc`.
    - Si je demande "éditeur de registre", avertissez du danger et suggérez de lancer `!regedit`.
    - Si je demande "moniteur de ressources", suggérez de lancer `!resmon`.
    - Si je demande "gestionnaire de tâches", suggérez de lancer `!taskmgr`.
    - Si je demande "invite de commandes", suggérez de lancer `!cmd`.
    - Si je demande "explorateur", suggérez de lancer `!explorer`.
    De même pour les autres utilitaires.
    ```

2.  **Exécutez le scénario et donnez la commande :**

    ```
    > Utilisez les instructions de 'open-windows-tools.md'. Ouvrez le planificateur de tâches.
    ```
**Résultat :** Gemini comprendra le contexte du fichier et votre demande, puis suggérera d'exécuter la commande nécessaire.

> **Réponse de Gemini :**
> ```text
> Ok, ouverture du Planificateur de tâches.
>
> Exécuter `!taskschd.msc` ? (y/n)
> ```
Après confirmation, l'utilitaire Windows standard s'ouvrira sur votre écran.
```