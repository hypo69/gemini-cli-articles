### **תרחיש עבור Gemini CLI: משחק "החיים"**

#### **שלב 1: יצירת הוראת מערכת `GEMINI.md`**

צור תיקיית `.gemini` בתיקיית העבודה של הפרויקט. בתוך `.gemini`, צור קובץ `GEMINI.md` והכנס לתוכו את הוראת המערכת. דוגמה להוראה:

````markdown
## 📘 הוראה ליצירת קוד Python

### 1. כללים כלליים

* השתמש ב-**Python 3.10+**.
* הקפד על **סגנון קידוד ברור, קריא וחד משמעי**.
* **כל פונקציה, מתודה ומחלקה** צריכים לכלול:

  * הערת סוגים (`type hints`)
  * תיעוד מלא ונכון בפורמט `docstring` (ראה סעיף 3)
  * הערות פנימיות (`#`), היכן שצריך

---

### 2. הערות

* הערות צריכות להיות **מדויקות** ולתאר **מה הקוד עושה**, ולא «מה אנחנו עושים».
* **אסור** להשתמש בכינויי גוף: `עושים`, `מחזירים`, `שולחים`, `עוברים` וכו'.
* **מותרים** רק מונחים: `חילוץ`, `ביצוע`, `קריאה`, `החלפה`, `בדיקה`, `שליחה`, `הפונקציה מבצעת`, `הפונקציה משנה ערך` וכו'.

#### ❌ דוגמה להערה שגויה:

<pre>```python
# מקבלים את ערך הפרמטר
````

#### ✅ דוגמה להערה נכונה:

<pre>```python
# הפונקציה מחלצת את ערך הפרמטר
```

---

### 3. Docstring (פורמט תיעוד)

כל פונקציה/מתודה/מחלקה צריכה לכלול `docstring` בפורמט הבא:

<pre>```python
def function(param: str, param1: Optional[str | dict | str] = None) -> dict | None:
    """
    Args:
        param (str): תיאור הפרמטר `param`.
        param1 (Optional[str | dict | str], optional): תיאור הפרמטר `param1`. ברירת מחדל `None`.

    Returns:
        dict | None: תיאור ערך ההחזרה. מחזיר מילון או `None`.

    Raises:
        SomeError: תיאור המצב שבו מתרחשת החריגה `SomeError`.

    Example:
        >>> function('param', 'param1')
        {'param': 'param1'}
    """
```

* **כל הפרמטרים וערכי ההחזרה צריכים להיות מתוארים.**
* הניסוחים צריכים להיות **תמציתיים, מדויקים וחד משמעיים**.
* אין להשמיט תיאור של פרמטרים/ערכי החזרה/חריגות.

---

### 4. הערת סוגים

* **כל המשתנים, הפרמטרים וערכי ההחזרה** צריכים להיות מוערים.
* השתמש בתחביר Python 3.10+: `list[int]`, `dict[str, Any]`, `str | None` וכו'.
* דוגמאות להערות נכונות:

#### ✅ סוגים פשוטים:

<pre>```python
name: str = "John"
count: int = 42
flag: bool = True
```

#### ✅ אוספים וסוגים מורכבים:

<pre>```python
from typing import Any, Optional, Callable, TypeAlias

coordinates: tuple[float, float] = (55.75, 37.61)
metadata: dict[str, Any] = {"debug": True}
UserId: TypeAlias = int
```

#### ✅ פונקציות ומתודות:

<pre>```python
def get_user_name(user_id: int) -> str:
    """מחזירה את שם המשתמש לפי המזהה שלו."""
    ...
```

#### ✅ פונקציות אסינכרוניות:

<pre>```python
async def fetch_users() -> AsyncIterator[dict[str, int | str]]:
    ...
```

#### ✅ סוגים גנריים:

<pre>```python
from typing import TypeVar, Generic

T = TypeVar("T")

class Container(Generic[T]):
    def __init__(self, value: T) -> None:
        self.value = value

    def get(self) -> T:
        return self.value
```

---

### 5. אחר

* השתמש ב-`default_factory` ב-`dataclass` עבור ערכים ניתנים לשינוי (`list`, `dict`).
* עבור ערכי `Optional`, ציין `T | None` (Python 3.10+) או `Optional[T]`.
* עבור מבנים מורכבים — השתמש ב-`TypeAlias`..

---

📌 **טיפ:** אחסון `GEMINI.md` ב-`.gemini` הוא נוהג סטנדרטי עבור gemini-cli. בעת יצירת קוד, כלול תמיד הערת סוגים, `docstring` והימנע מניסוחים סובייקטיביים בהערות. המטרה היא מבנה קוד מדויק, ניתן לשחזור ומפורמל ככל האפשר.

---

לנוחות, ניצור תיקיית `game`, בה ישמרו קבצי הפרויקט, ותיקיית `scenarios`, בה ישמרו תרחישים עבור Gemini CLI:

* `scenarios/life-create-code.md` — הוראות ליצירת קוד המשחק "החיים"
* `scenarios/life-create-test.md` — הוראות ליצירת בדיקות
* `scenarios/life-create-doc.md` — הוראות ליצירת תיעוד

---

### **life-create-code.md**

```markdown
בתוך תיקיית `game`, צור קובץ life.py. 
יישם את "משחק החיים" של קונוויי ב-Python, תוך שימוש בגישה מונחית עצמים.
השתמש בספריות: `numpy`, `pygame` (לגרפיקה).

דרישות:
1.  צור מחלקה `Game`.
2.  ב-`__init__` המחלקה צריכה לקבל את מימדי הרשת (רוחב, גובה) וליצור שדה התחלתי אקראי.
3.  צור מתודה `step()`, המעדכנת את מצב המשחק בצעד אחד:
    - תא חי עם < 2 שכנים חיים מת (בדידות).
    - תא חי עם 2 או 3 שכנים חיים שורד.
    - תא חי עם > 3 שכנים חיים מת (צפיפות יתר).
    - תא מת עם בדיוק 3 שכנים חיים הופך לחי (לידה).
4.  צור מתודה `display()` או דרוס את `__str__`, כדי להציג את השדה בקונסולה ('■' לתא חי, ' ' לתא מת).
5.  השתמש ב-`numpy` לעבודה יעילה עם הרשת.
6.  בבלוק `if __name__ == '__main__':` הוסף דוגמה שיוצרת את המשחק ומפעילה סימולציה עם השהיה קצרה בין צעדים.
7. להדמיית המשחק השתמש ב-`pygame` או בספריית גרפיקה אחרת.
```

---

### **life-create-test.md**

```markdown
בתוך תיקיית `game`, צור קובץ test_life.py, תוך שימוש בהקשר מהקובץ @life.py. השתמש בפריימוורק pytest.

הבדיקה צריכה לבדוק את התפתחותו של מתנד פשוט "מהבהב":

1. ייבא את המחלקה `Game` מתוך `life`.
2. צור פונקציית בדיקה, לדוגמה `test_blinker_oscillation`.
3. צור מופע של `Game` בגודל קבוע (לדוגמה, 5x5).
4. הגדר ידנית את המצב ההתחלתי של השדה: קו אופקי של שלושה תאים חיים במרכז.
5. קרא ל-`game.step()`.
6. באמצעות `assert` ו-`numpy.array_equal` בדוק שהשדה השתנה לקו אנכי של שלושה תאים.
7. קרא ל-`game.step()` שוב.
8. בדוק שהשדה חזר למצבו האופקי המקורי.
```

---

### **life-create-doc.md**

```markdown
נתח את הקבצים @life.py ו-@test_life.py בתוך תיקיית `game` ועל בסיסם צור קובץ תיעוד doc.md.

מבנה התיעוד:
- **כותרת:** # פרויקט "משחק החיים"
- **תיאור קצר:** יישום אוטומט תאי של קונוויי.
- **מבנה קבצים:** תיאור קצר של מטרת הקבצים `life.py` ו-`test_life.py`.
- **כיצד להפעיל את הסימולציה:** פקודה להפעלת הקובץ הראשי (`python life.py`).
- **כיצד להפעיל את הבדיקות:** פקודות להתקנת תלויות (`pip install pytest numpy`) ולהפעלת בדיקות (`pytest`).
```

---

### **שלב 2: יצירת קוד המשחק "החיים"**

אנו מפעילים את gemini-cli בטרמינל. חשוב! ודא שאתה נמצא בתיקייה שבה נמצא `.gemini/GEMINI.md`.

1. אנו נותנים הרשאה ליצירת הקובץ.
2. Gemini CLI ייצור את הקובץ `life.py` בתיקיית `game`.
3. אנו יוצרים סביבה וירטואלית venv, מתקינים תלויות ומפעילים את המשחק.

---

### **שלב 3: יצירת בדיקות**

1. Gemini CLI יוצר את הקובץ `test_life.py` בתיקיית `game`.
2. אנו בודקים תרחישים פשוטים, לדוגמה, מתנד "מהבהב".
3. אנו מתקנים שגיאות במידת הצורך.

---

### **שלב 4: יצירת תיעוד**

1. Gemini CLI מנתח את `life.py` ו-`test_life.py`.
2. יוצר את הקובץ `doc.md` עם תיאור הפרויקט, הוראות להפעלת המשחק והבדיקות.

וואלה! הפרויקט מוכן.