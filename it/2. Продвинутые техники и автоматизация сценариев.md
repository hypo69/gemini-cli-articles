## Gemini CLI: Tecniche avanzate e automazione degli scenari.

Nella prima parte, abbiamo trattato le basi: installazione, autenticazione ed esecuzione di singoli comandi. Ora passiamo al livello successivo. In questa parte, insegneremo a Gemini CLI a eseguire scenari complessi e a più passaggi che possono essere salvati, riutilizzati e condivisi con il team. Questo trasformerà lo strumento da un semplice assistente a un potente motore di automazione.

### Meccanismo di esecuzione degli scenari

L'idea chiave è utilizzare i file `.md` come "ricette" o "scenari" per Gemini. All'interno di un tale file, descriviamo in linguaggio naturale la sequenza di azioni che l'IA dovrebbe eseguire.

Per eseguire uno scenario, utilizzeremo lo strumento integrato `ReadFile`. Chiederemo semplicemente a Gemini di leggere il file con le istruzioni e di eseguirle.

**Comando principale per eseguire qualsiasi scenario:**
```
> Leggi ed esegui le istruzioni dal file 'nome_scenario.md'
```

Ora esaminiamo alcuni scenari utili.

Crea una directory `scenarios`.
```bash
/path/to/gemini-cli > mkdir scenarios
```

in essa memorizzeremo i nostri scenari.

### Scenario: "Audit del repository Git"

Questo compito è familiare a ogni sviluppatore: prima di iniziare a lavorare, è necessario controllare lo stato attuale del progetto. Creiamo uno scenario che lo farà per noi.

1.  **Nella directory `scenarios`, crea il file `git-health-check.md`** con il seguente contenuto:

    ```markdown
    Sei un ingegnere Git esperto. Il tuo compito è condurre un audit completo del repository corrente. 
    
    Esegui i seguenti passaggi rigorosamente in ordine e attendi la mia conferma per ogni comando: 
    
    1.  **Controlla lo stato:** Mostrami lo stato corrente del repository per vedere i file non tracciati o modificati. Suggerisci il comando `!git status`.
    2.  **Recupera gli aggiornamenti:** Ottieni le ultime modifiche dal server remoto, ma non applicarle. Suggerisci il comando `!git fetch origin`.
    3.  **Confronta i rami:** Mostrami la differenza tra il mio ramo locale `main` e il ramo remoto `origin/main`. Suggerisci il comando `!git log main..origin/main --oneline`.
    4.  **Trova file di grandi dimensioni:** Trova i 5 file più grandi nel progetto che non si trovano in `.git`. Suggerisci il comando `!find . -type f -not -path "./.git/*" -printf "%s %p\n" | sort -rn | head -n 5`.
    5.  **Riepiloga:** Infine, descrivi brevemente lo stato del repository in base ai dati ottenuti.
    ```

2.  **Esegui lo scenario in Gemini CLI:**

    ```
    > Leggi ed esegui lo scenario 'git-health-check.md'
    ```

![1](assets/1.png)


In realtà, non esiste un repository in questa directory, Gemini proporrà di crearne uno nuovo.
Gemini CLI correggerà autonomamente gli errori durante la creazione del repository, ad esempio, se hai dimenticato di inizializzarlo, lo proporrà,
nonché gli errori attuali durante l'esecuzione dello scenario.

## Passaggio 1: Controllo dello stato

![2](assets/2.png)

Risposta di Gemini:
```text
>✦ Sono un ingegnere Git esperto. Inizio l'audit del tuo repository.
> Passaggio 1: Controllo dello stato
>Per controllare lo stato corrente del repository e vedere i file non tracciati o modificati, eseguirò il comando `git status`.
```
Esecuzione del comando `git status`...
![3](assets/3.png)

Risposta di Gemini:
```text
✦ Errore: C:\Users\user\Documents\repos non è un repository Git. 

  Specifica in quale delle sottodirectory devo eseguire l'audit. Ad esempio, public_repositories.
```
Chiediamo di creare un nuovo repository.
![4](assets/4.png)
Risposta di Gemini:
```text
✦ Ottimo, il repository Git è stato creato. Ora posso continuare l'audit.


  Eseguo git status per verificare la presenza di file non tracciati.
```
![5](assets/5.png)

...

![6](assets/6.png)

Risposta di Gemini:
```text
✦ Ci sono molti file e cartelle non tracciati nel repository. Per continuare, devo aggiungerli all'indice. Aggiungerò tutti i file.
```

![7](assets/7.png)
...
![8](assets/8.png)

Si è verificato un errore durante l'esecuzione del comando
```text
error: pathspec 'commit"' did not match any file(s) known to git
```
Risposta di Gemini:
```text
✦ Sembra che ci sia stato un errore di virgolette nel comando. Proverò di nuovo, usando virgolette singole per il messaggio di commit.
```

![9](assets/9.png)
![10](assets/10.png)
Questa volta ha funzionato!

Risposta di Gemini:
```text
✦ Ottimo, il primo commit è stato creato con successo. Ora eliminerò il file temporaneo con il messaggio di commit.
```
Ora gemini eliminerà il file temporaneo con il messaggio di commit.

gemini cli applica sequenzialmente il comando pertinente ('rm','del')

![11](assets/11.png)



### Passaggio 2: Recupero degli aggiornamenti
Poiché il repository remoto non esiste, gemini cli riceverà un errore.
Nota che si aspetta un errore.

![12](assets/12.png)

### Passaggio 3: Confronto dei rami

Anche qui ci sarà un errore, poiché il ramo `main` non esiste.
![13](assets/13.png)

###   Passaggio 4: Ricerca di file di grandi dimensioni

![14](assets/14.png)
Risposta di Gemini:
```text
Il comando `find` non ha funzionato perché in Windows è necessario utilizzare `dir`. Gemini correggerà l'errore e suggerirà il comando corretto.

Successivamente, gemini cli ragiona sulle seguenti azioni:
✦ THINK: The user wants me to find the 5 largest files in the project.
  The previous command find . -type f -not -path ".\.git\*" -printf "%s %p\n" | sort -rn | head -n 5 failed because find, sort, and head
  are not native Windows commands. I need to use a PowerShell equivalent.

   1. Get all files: Get-ChildItem -Recurse -File
   2. Exclude .git directory: Where-Object { $_.FullName -notlike "*.git\*" }
   3. Sort by size (descending): Sort-Object -Property Length -Descending
   4. Select the top 5: Select-Object -First 5
   5. Format the output: ForEach-Object { "{0} {1}" -f $_.Length, $_.FullName }

  Let's combine these into a single PowerShell command.Sembra che find e head non siano disponibili nel tuo ambiente Windows. Userò PowerShell,
  per eseguire lo stesso compito.
```
![15](assets/15.png)

Di nuovo un errore.

gemini cli continua a ragionare su cosa fare dopo:
```text
 
✦ THINK: The user wants to find the 5 largest files.
  The PowerShell command is still not executing correctly. It seems that the pipe | and special characters are being misinterpreted by the
  shell when passed as a single command string.

  I will try to execute the command by first saving the script to a file and then executing the file with PowerShell.

   1. Create a PowerShell script file (find_large_files.ps1).
   2. The content of the script will be: Get-ChildItem -Recurse -File | Where-Object { $_.FullName -notlike "*.git\*" } | Sort-Object
      -Property Length -Descending | Select-Object -First 5 | Format-Table Length, FullName -AutoSize
   3. Execute the script using powershell -File find_large_files.ps1.
   4. Delete the script file.Sembra che il passaggio di comandi complessi a PowerShell direttamente causi problemi. Creerò un file di script temporaneo
      PowerShell, lo eseguirò e poi lo eliminerò.

```
![16](assets/16.png)

Questa volta tutto ha funzionato!

### Passaggio 5: Riepilogo
gemini cli riepiloga:
```text
 Stato del repository: 

   * Repository locale: Inizializzato, e tutti i file nella cartella radice C:\Users\user\Documents\repos sono stati aggiunti al primo commit.
   * Repository remoto: Non configurato. Non c'è un'origine remota, quindi è impossibile ottenere aggiornamenti o confrontare i rami.
   * File di grandi dimensioni: Sono stati trovati diversi file molto grandi, principalmente nelle sottodirectory venv e public_repositories. I più grandi sono
     le librerie .lib e gli archivi .zip. Si consiglia di aggiungere i percorsi contenenti file binari di grandi dimensioni (ad esempio, venv, *.zip) al file .gitignore,
     per evitare che vengano inclusi nel repository.

  Audit completato.
```
![17](assets/17.png)


### Scenario: "Pulizia dell'ambiente Docker"

Docker accumula nel tempo molte immagini, container e reti inutili. Questo scenario aiuterà a pulire tutto in sicurezza.

1.  **Crea il file `docker-cleanup.md`**:

    ```markdown
    Sei un ingegnere DevOps, responsabile della pulizia del sistema. Il tuo compito è pulire in sicurezza l'ambiente Docker.
    
    Procedi passo dopo passo:
    
    1.  **Mostra i container in esecuzione:** Per prima cosa, elenca tutti i container attivi in modo che io possa assicurarmi di non fermare nulla di importante. Suggerisci `!docker ps`.
    2.  **Ferma tutti i container:** Dopo la mia approvazione, suggerisci un comando per fermare TUTTI i container in esecuzione. Comando: `!docker stop $(docker ps -q)`.
    3.  **Pulizia globale:** Ora esegui una pulizia completa del sistema di immagini "dangling", container fermi, reti inutilizzate e cache di build. Suggerisci il comando più sicuro ed efficiente `!docker system prune -af`.
    4.  **Report:** Dopo l'esecuzione, riporta quanto spazio è stato liberato, in base all'output dell'ultimo comando.
    ```

2.  **Esegui lo scenario in Gemini CLI:**

    ```
    > Leggi ed esegui lo scenario di pulizia Docker dal file 'docker-cleanup.md'
    ```
**Risultato:** Gemini ti guiderà attraverso un processo di pulizia sicuro, chiedendo conferma a ogni passaggio critico.

---


### Scenario: "Avvio di applicazioni di sistema"

Come mostrato nell'esempio, Gemini gestisce l'avvio delle applicazioni in modo eccellente. Formalizziamo questo in uno scenario semplice per Windows.

1.  **Crea il file `open-windows-tools.md`**:

    ```markdown
    Sei un amministratore di sistema Windows. Il tuo compito è aprire le utilità di sistema su richiesta.

    - Se chiedo "Utilità di pianificazione", suggerisci di avviare `!taskschd.msc`.
    - Se chiedo "Editor del Registro di sistema", avvisa del pericolo e suggerisci di avviare `!regedit`.
    - Se chiedo "Monitoraggio risorse", suggerisci di avviare `!resmon`.
    - Se chiedo "Gestione attività", suggerisci di avviare `!taskmgr`.
    - Se chiedo "Prompt dei comandi", suggerisci di avviare `!cmd`.
    - Se chiedo "Esplora file", suggerisci di avviare `!explorer`.
    Analogamente per altre utilità.
    ```

2.  **Esegui lo scenario e dai il comando:**

    ```
    > Usa le istruzioni da 'open-windows-tools.md'. Apri Utilità di pianificazione.
    ```
**Risultato:** Gemini comprenderà il contesto dal file e la tua richiesta, quindi suggerirà di eseguire il comando necessario.

> **Risposta di Gemini:**
> ```text
> Ok, apro Utilità di pianificazione.
>
> Esegui `!taskschd.msc`? (s/n)
> ```
Dopo la conferma, l'utilità standard di Windows si aprirà sul tuo schermo.

```