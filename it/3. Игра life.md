### **Scenario per Gemini CLI: Gioco "Vita"**

#### **Passaggio 1: Creazione di un'istruzione di sistema `GEMINI.md`**

Crea una directory `.gemini` nella cartella di lavoro del progetto. All'interno di `.gemini`, crea un file `GEMINI.md` e inserisci l'istruzione di sistema. Esempio di istruzione:

````markdown
## üìò Istruzione per la generazione di codice Python

### 1. Regole generali

* Utilizza **Python 3.10+**.
* Aderisci a uno **stile di codifica chiaro, leggibile e inequivocabile**.
* **Ogni funzione, metodo e classe** deve avere:

  * Annotazione dei tipi (`type hints`)
  * Documentazione completa e corretta nel formato `docstring` (vedi sezione 3)
  * Commenti interni (`#`), dove necessario

---

### 2. Commenti

* I commenti devono essere **precisi** e descrivere **cosa fa il codice**, non ¬´cosa facciamo¬ª.
* **Vietato** utilizzare pronomi: `facciamo`, `restituiamo`, `inviamo`, `andiamo` ecc.
* **Consentiti** solo termini: `estrazione`, `esecuzione`, `chiamata`, `sostituzione`, `controllo`, `invio`, `La funzione esegue`, `La funzione modifica il valore` ecc.

#### ‚ùå Esempio di commento errato:

<pre>```python
# Otteniamo il valore del parametro
````

#### ‚úÖ Esempio di commento corretto:

<pre>```python
# La funzione estrae il valore del parametro
```

---

### 3. Docstring (formato di documentazione)

Ogni funzione/metodo/classe deve contenere un `docstring` nel seguente formato:

<pre>```python
def function(param: str, param1: Optional[str | dict | str] = None) -> dict | None:
    """
    Args:
        param (str): Descrizione del parametro `param`.
        param1 (Optional[str | dict | str], optional): Descrizione del parametro `param1`. Per impostazione predefinita `None`.

    Returns:
        dict | None: Descrizione del valore di ritorno. Restituisce un dizionario o `None`.

    Raises:
        SomeError: Descrizione della situazione in cui si verifica l'eccezione `SomeError`.

    Example:
        >>> function('param', 'param1')
        {'param': 'param1'}
    """
```

* **Tutti i parametri e i valori di ritorno devono essere descritti.**
* Le formulazioni devono essere **concise, accurate e inequivocabili**.
* Non √® consentito omettere la descrizione di parametri/valori di ritorno/eccezioni.

---

### 4. Annotazione dei tipi

* **Tutte le variabili, i parametri e i valori di ritorno** devono essere annotati.
* Utilizza la sintassi Python 3.10+: `list[int]`, `dict[str, Any]`, `str | None` ecc.
* Esempi di annotazioni corrette:

#### ‚úÖ Tipi semplici:

<pre>```python
name: str = "John"
count: int = 42
flag: bool = True
```

#### ‚úÖ Collezioni e tipi complessi:

<pre>```python
from typing import Any, Optional, Callable, TypeAlias

coordinates: tuple[float, float] = (55.75, 37.61)
metadata: dict[str, Any] = {"debug": True}
UserId: TypeAlias = int
```

#### ‚úÖ Funzioni e metodi:

<pre>```python
def get_user_name(user_id: int) -> str:
    """Restituisce il nome dell'utente tramite il suo ID."""
    ...
```

#### ‚úÖ Funzioni asincrone:

<pre>```python
async def fetch_users() -> AsyncIterator[dict[str, int | str]]:
    ...
```

#### ‚úÖ Tipi generici:

<pre>```python
from typing import TypeVar, Generic

T = TypeVar("T")

class Container(Generic[T]):
    def __init__(self, value: T) -> None:
        self.value = value

    def get(self) -> T:
        return self.value
```

---

### 5. Altro

* Utilizza `default_factory` in `dataclass` per valori mutabili (`list`, `dict`).
* Per i valori `Optional`, specifica `T | None` (Python 3.10+) o `Optional[T]`.
* Per strutture complesse ‚Äî utilizza `TypeAlias`.

---

üìå **Suggerimento:** L'archiviazione di `GEMINI.md` in `.gemini` √® una pratica standard per gemini-cli. Durante la generazione del codice, includi sempre l'annotazione dei tipi, il `docstring` ed evita formulazioni soggettive nei commenti. L'obiettivo √® una struttura del codice il pi√π precisa, riproducibile e formalizzata possibile.

---

Per comodit√†, creeremo una directory `game`, in cui verranno archiviati i file di progetto, e una directory `scenarios`, in cui verranno archiviati gli scenari per Gemini CLI:

* `scenarios/life-create-code.md` ‚Äî istruzioni per la creazione del codice del gioco "Vita"
* `scenarios/life-create-test.md` ‚Äî istruzioni per la creazione di test
* `scenarios/life-create-doc.md` ‚Äî istruzioni per la creazione della documentazione

---

### **life-create-code.md**

```markdown
Nella directory `game`, crea il file life.py.
Implementa il "Gioco della Vita" di Conway in Python, utilizzando un approccio orientato agli oggetti.
Utilizza le librerie: `numpy`, `pygame` (per la grafica).

Requisiti:
1.  Crea la classe `Game`.
2.  In `__init__`, la classe dovrebbe accettare le dimensioni della griglia (larghezza, altezza) e creare un campo iniziale casuale.
3.  Crea il metodo `step()`, che aggiorna lo stato del gioco di un passo:
    - Una cellula vivente con < 2 vicini vivi muore (solitudine).
    - Una cellula vivente con 2 o 3 vicini vivi sopravvive.
    - Una cellula vivente con > 3 vicini vivi muore (sovrappopolazione).
    - Una cellula morta con esattamente 3 vicini vivi diventa viva (riproduzione).
4.  Crea il metodo `display()` o sovrascrivi `__str__`, per visualizzare il campo nella console ('‚ñ†' per una cellula viva, ' ' per una cellula morta).
5.  Utilizza `numpy` per operazioni efficienti sulla griglia.
6.  Nel blocco `if __name__ == '__main__':` aggiungi un esempio che crea un gioco e avvia la simulazione con un piccolo ritardo tra i passaggi.
7. Per la visualizzazione del gioco, utilizza `pygame` o un'altra libreria grafica.
```

---

### **life-create-test.md**

```markdown
Nella directory `game`, crea il file test_life.py, utilizzando il contesto del file @life.py. Utilizza il framework pytest.

Il test dovrebbe verificare l'evoluzione di un semplice oscillatore "Blinker":

1. Importa la classe `Game` da `life`.
2. Crea una funzione di test, ad esempio `test_blinker_oscillation`.
3. Crea un'istanza di `Game` con una dimensione fissa (ad esempio, 5x5).
4. Imposta manualmente lo stato iniziale del campo: una linea orizzontale di tre cellule vive al centro.
5. Chiama `game.step()`.
6. Usando `assert` e `numpy.array_equal`, verifica che il campo sia cambiato in una linea verticale di tre cellule.
7. Chiama `game.step()` di nuovo.
8. Verifica che il campo sia tornato al suo stato orizzontale originale.
```

---

### **life-create-doc.md**

```markdown
Analizza i file @life.py e @test_life.py all'interno della directory `game` e, sulla base di essi, crea un file di documentazione doc.md.

Struttura della documentazione:
- **Titolo:** # Progetto "Gioco della Vita"
- **Breve descrizione:** Implementazione dell'automa cellulare di Conway.
- **Struttura dei file:** Breve descrizione dello scopo dei file `life.py` e `test_life.py`.
- **Come avviare la simulazione:** Comando per avviare il file principale (`python life.py`).
- **Come eseguire i test:** Comandi per installare le dipendenze (`pip install pytest numpy`) ed eseguire i test (`pytest`).
```

---

### **Passaggio 2: Creazione del codice del gioco "Vita"**

Avvia gemini-cli nel terminale. Importante! Assicurati di essere nella directory in cui si trova `.gemini/GEMINI.md`.

1. Concedi il permesso di creare il file.
2. Gemini CLI generer√† il file `life.py` nella directory `game`.
3. Crea un ambiente virtuale venv, installa le dipendenze e avvia il gioco.

---

### **Passaggio 3: Creazione di test**

1. Gemini CLI genera il file `test_life.py` nella directory `game`.
2. Testa scenari semplici, come l'oscillatore "Blinker".
3. Correggi gli errori se necessario.

---

### **Passaggio 4: Creazione della documentazione**

1. Gemini CLI analizza `life.py` e `test_life.py`.
2. Genera un file `doc.md` con una descrizione del progetto, istruzioni per l'avvio del gioco e i test.

Voila! Il progetto √® pronto.
