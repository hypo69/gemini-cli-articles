<h2>Gemini CLI: Wprowadzenie i pierwsze kroki.</h2>
<p><strong>Gemini CLI</strong> to narzędzie, które działa bezpośrednio w Twoim terminalu, rozumie Twoją bazę kodu i pomaga naprawiać błędy za pomocą zapytań w języku naturalnym. To odpowiedź Google na Claude Code firmy Anthropic.
Możesz używać Gemini 2.5 Pro (narzędzie przełączy się na Gemini 2.5 Flash po osiągnięciu limitu) i jego okna kontekstowego o pojemności 1 miliona tokenów, aby wykonywać do 60 zapytań na minutę i 1000 zapytań dziennie, a wszystko to za darmo.</p>
<h3>Spis treści</h3>
<ul>
<li>Zrozumienie i nawigacja po dużych bazach kodu</li>
<li>Wykrywanie i naprawianie błędów</li>
<li>Pisanie i testowanie kodu</li>
<li>Narzędzia Gemini CLI</li>
<li>Integracja Google CLI z MCP</li>
</ul>
<h3>Kluczowe funkcje Gemini CLI:</h3>
<ul>
<li><strong>Edycja i refaktoryzacja:</strong> Automatycznie poprawia i upraszcza Twój kod pod kierunkiem AI.</li>
<li><strong>Wykrywanie i naprawianie błędów:</strong> Znajduje błędy i sugeruje poprawki.</li>
<li><strong>Zrozumienie kodu:</strong> Gemini CLI może podsumować architekturę, wyjaśnić role modułów lub zbudować mapy przepływu wykonania.</li>
<li><strong>Generowanie testów:</strong> Automatycznie tworzy przypadki testowe dla `pytest`</li>
<li><strong>Wsparcie dokumentacji:</strong> Możesz tworzyć ustrukturyzowane dokumenty Markdown, dzienniki zmian (changelogi) i odpowiadać na problemy GitHub bezpośrednio w terminalu.</li>
<li><strong>Wykonywanie poleceń:</strong> Gemini CLI może wykonywać polecenia powłoki, takie jak `git`, `npm`, `pip` i inne, co pozwala zarządzać projektami bez wychodzenia z CLI.</li>
</ul>
<hr>
<h3>Krok 1: Wymagania wstępne</h3>
<p>Aby rozpocząć, zainstaluj Node.js (wersja 18 lub nowsza). Możesz pobrać instalator według własnego wyboru lub uruchomić następujące polecenia bash w swoim terminalu:</p>
<pre class="line-numbers"><code class="language-bash"># Pobieranie i instalacja nvm (Node Version Manager):
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash

# Inicjalizacja nvm w bieżącej sesji terminala
. "$HOME/.nvm/nvm.sh"

# Pobieranie i instalacja Node.js (np. wersja 22):
nvm install 22

# Sprawdzenie wersji Node.js:
node -v # Powinno wyświetlić "v22.17.0" lub podobne

# Sprawdzenie wersji npm:
npm -v # Powinno wyświetlić "10.9.2" lub podobne
</code></pre>
<blockquote>
<p>⚠️ <strong>Ważne dla użytkowników Windows:</strong>
Powyższe polecenie <code>nvm</code> jest przeznaczone dla <strong>Linux/macOS</strong> i <strong>nie będzie działać w PowerShell ani cmd.exe</strong>.
Dla systemu Windows użyj [nvm-windows](https://github.com/coreybutler/nvm-windows), pobierając <code>nvm-setup.exe</code> z sekcji [Releases](https://github.com/coreybutler/nvm-windows/releases).
Alternatywnie możesz zainstalować WSL (Windows Subsystem for Linux) i uruchomić polecenia w Ubuntu lub innej dystrybucji Linuksa.</p>
</blockquote>
<hr>
<h3>Krok 2: Konfiguracja Gemini CLI</h3>
<h4>Krok 2.1: Instalacja Gemini CLI</h4>
<p>Po zainstalowaniu i zweryfikowaniu Node.js i npm, zainstaluj Gemini CLI, uruchamiając następujące polecenie w swoim terminalu:</p>
<pre class="line-numbers"><code class="language-bash">npx https://github.com/google-gemini/gemini-cli
</code></pre>
<p>Lub użyj <code>npm</code> do globalnej instalacji:</p>
<pre class="line-numbers"><code class="language-bash">npm install -g @google/gemini-cli
gemini
</code></pre>
<p>Po instalacji wpisz <code>gemini</code> w terminalu, aby uzyskać dostęp do narzędzia.</p>
<h4>Krok 2.2: Uwierzytelnianie</h4>
<p>Możesz użyć swojego osobistego konta Google do uwierzytelniania. Zapewni to do 60 zapytań na minutę i 1000 zapytań dziennie podczas korzystania z Gemini.
<p><img src="assets/gemini_cli_1/auth.png" alt="First Run"></p>
<p>W tym przewodniku użyłem <strong>Zaloguj się przez Google</strong>, ale możesz również użyć <strong>klucza API</strong> (ustawionego jako zmienna środowiskowa lub w pliku `.env`) lub uwierzytelniania <strong>Vertex AI</strong>.

Aby wygenerować nowy klucz API, zaloguj się do <strong>AI Studio</strong> za pomocą swojego konta Google i kliknij "Utwórz klucz API".
```bash
# Ustaw klucz jako zmienną środowiskową
export GEMINI_API_KEY="Your_API_Key"

# Lub utwórz plik .env
GEMINI_API_KEY="Your_API_Key"
```
Możesz użyć polecenia <code>/auth</code> w polu tekstowym, aby w razie potrzeby przełączyć metody uwierzytelniania.

---

<h3>Krok 3: Konfiguracja projektu w Gemini CLI</h3>
<p><img src="assets/gemini_cli_1/start.png" alt="Start"></p>
<p>Po uruchomieniu CLI możemy rozpocząć interakcję z Gemini z terminala. Istnieją dwa sposoby pracy z projektem.</p>
<h4>1. Rozpocznij nowy projekt</h4>
<p>Aby rozpocząć projekt od zera, uruchom następujące polecenia:
<pre class="line-numbers"><code class="language-bash">cd new-project/
gemini
</code></pre>
<p>Wewnątrz CLI użyj monitu, aby rozwiązać interesujący Cię problem, na przykład:
> Napisz kod kodera dla transformatora od podstaw.
![Example 1](assets/gemini_cli_1/example_1.png)
Udziel pozwolenia na zapisywanie plików:
![File](assets/gemini_cli/file.png)

<h4>2. Pracuj z istniejącym projektem</h4>
<p>Jeśli masz już bazę kodu, możesz z nią pracować, uruchamiając następujące polecenia:
<pre class="line-numbers"><code class="language-bash">git clone https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo
cd Google-Agent-Development-Kit-Demo
gemini
</code></pre>
<p>Wewnątrz CLI użyj monitu, na przykład:
> Podaj mi podsumowanie wszystkich zmian wprowadzonych w bazie kodu w ciągu ostatniego miesiąca.

---

<h3>Krok 4: Eksperymentowanie z Gemini CLI</h3>
<p>Jako przykład użyję projektu <strong>[Planer podróży oparty na ADK 🌍🛫](https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo)**.
Z Gemini CLI pokażę, jak:
<ol>
<li>przeglądać bazę kodu</li>
<li>wykrywać błędy lub problemy na GitHubie lub w pliku</li>
<li>refaktoryzować kod i generować testy jednostkowe</li>
<li>tworzyć raport Markdown z wprowadzonych zmian</li>
<li>wizualizować bazę kodu, generując schemat blokowy</li>
</ol>
<h4>Przeglądanie i zrozumienie bazy kodu</h4>
<p>Zacznijmy od poproszenia Gemini o przejrzenie i wyjaśnienie bazy kodu.</p>
<p><strong>Monit:</strong> `Przeglądaj bieżący katalog i opisz architekturę projektu.`</p>
<p>Gemini CLI zwróci ustrukturyzowane podsumowanie wyjaśniające architekturę:
*   **Interfejs użytkownika:** Aplikacja Streamlit (`travel_ui.py`) zapewnia interfejs do interakcji.
*   **Orkiestracja:** `host_agent` działa jako centralny koordynator.
*   **Wyspecjalizowani agenci:** `flight_agent`, `stay_agent`, `activities_agent` do wyszukiwania lotów, hoteli i atrakcji.
*   **Komunikacja:** Agenci komunikują się ze sobą za pośrednictwem interfejsu API RESTful FastAPI.
*   **Wspólne komponenty:** `shared/schemas.py` definiuje wspólne struktury danych.

Pomoże to w nawigacji bez ręcznego czytania każdego pliku.

<h4>Analiza i naprawa problemu GitHub</h4>
<p>Przyjrzyjmy się kilku otwartym problemom z repozytorium GitHub.</p>
<p><strong>Monit:</strong> `Oto problem GitHub: [@search https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo/issues/1]. Przeanalizuj bazę kodu i zaproponuj 3-etapowy plan naprawy. Które pliki/funkcje należy zmienić?`</p>
<p>Gemini CLI zbadał problem:
*   Korzystając z funkcji `@search`, pobrał dane z GitHuba.
*   Zidentyfikował główną przyczynę jako błąd serializacji JSON (w tym przypadku asynchroniczna funkcja `create_session()` nie została wywołana z `await`).
*   Zaproponował zmiany i obsługę odpowiedzi w wielu plikach.

Następnie CLI czeka na dane wejściowe użytkownika w celu oceny zmian. Jeśli użytkownik się zgodzi, zastosuje sugerowane zmiany.

<h4>Implementacja i testowanie poprawki</h4>
<p>Teraz zaimplementujmy i przetestujmy poprawki sugerowane przez Gemini.

**Monit:** `Napisz test jednostkowy dla tej zmiany w pytest w pliku test_shared.py.`</p>
<p>Gemini CLI:
*   Wstawił `json.dumps()` przed wysłaniem ładunku zadania.
*   Utworzył `test_agents.py`, aby dodać testy jednostkowe.
*   Dodał nowy przypadek testowy, aby sprawdzić schemat i przekazać zagnieżdżone wiadomości agentów.

<h4>Generowanie dokumentacji</h4>
<p>Teraz, gdy poprawki zostały zastosowane, podsumujmy zmiany i zapiszmy je w Markdown w pliku `.txt`.

**Monit:** `Napisz podsumowanie Markdown błędu, poprawki i pokrycia testów. Sformatuj je jako wpis w dzienniku zmian pod wersją "v0.2.0".`</p>
<p>Następnie, aby zapisać podsumowanie w dokumencie, użyłem następującego monitu:

**Monit:** `Zapisz to podsumowanie w pliku .txt i nazwij je summary.txt`</p>
<p>Gemini CLI używa narzędzia `WriteFile` do zapisania pliku `summary.txt` w katalogu projektu.

<h4>Generowanie schematu blokowego za pomocą MCP</h4>
<p>Ta sekcja rozszerza poprzednie eksperymenty, w których badam, w jaki sposób Gemini CLI wykorzystuje **Model Context Protocol (MCP)** do utrzymywania podsumowań na poziomie plików i historii zadań między monitami. Daje to Gemini "pamięć roboczą" w ramach sesji.

**Monit:** `Wygeneruj schemat blokowy, który pokazuje, jak agenci komunikują się za pośrednictwem A2A (agent-to-agent) i jak main.py zarządza systemem. Podkreśl, gdzie wystąpił problem i jak został naprawiony.`</p>
<p>Ta wizualizacja była możliwa dzięki trwałej pamięci Gemini, która zachowała pełny kontekst naszej poprzedniej poprawki błędu i struktury agenta bez konieczności ponownego ładowania plików.

<h3>Dostępne narzędzia Gemini CLI</h3>
<p>Wywołanie polecenia `/tools` w Gemini CLI wyświetli listę dostępnych narzędzi, które można wykorzystać do wykonywania różnych zadań, takich jak edycja kodu, generowanie testów, tworzenie dokumentacji i wiele innych.</p>
<p><img src="assets/gemini_cli_1/tools.png" alt="Tools"></p>
<p><strong>ReadFolder (ls)</strong><br>
Wyświetla listę plików i folderów w katalogu — podobnie jak polecenie `ls` w wierszu poleceń.</p>
<p><strong>ReadFile (read-file)</strong><br>
Odczytuje pełną zawartość pojedynczego pliku, przydatne do tworzenia podsumowań lub analizy.</p>
<p><strong>ReadManyFiles (read-many-files)</strong><br>
Odczytuje wiele plików jednocześnie, zazwyczaj według wzorca (np. wszystkie pliki `.js`).</p>
<p><strong>FindFiles (glob)</strong><br>
Wyszukuje pliki według wzorca (np. znajdź wszystkie pliki `config.json` w swoim projekcie).

**SearchText (grep)**<br>
Wyszukuje tekst w plikach, na przykład, aby znaleźć wszystkie komentarze `TODO`.</p>
<p><strong>Edit (edit)</strong><br>
Stosuje zmiany w kodzie za pomocą `diff`. Gemini wyświetla podgląd edycji i prosi o potwierdzenie przed ich zastosowaniem.</p>
<p><strong>WriteFile (write-file)</strong><br>
Tworzy nowe pliki (np. `README.md`) z treścią dostarczoną przez użytkownika.</p>
<p><strong>Shell (shell)</strong><br>
Wykonuje polecenia bezpośrednio w terminalu, jeśli poprzedzisz je prefiksem `!` (np. `!npm test`).</p>
<p><strong>WebFetch (web-fetch)</strong><br>
Pobiera zawartość z sieci (HTML lub JSON), umożliwiając Gemini analizowanie danych zewnętrznych.</p>
<p><strong>GoogleSearch (web-search)</strong><br>
Wykonuje wyszukiwanie w Google, aby oprzeć odpowiedzi na rzeczywistych informacjach (np. aby znaleźć wyjaśnienie błędu).

**Save Memory (memoryTool)**<br>
Zapisuje fakty lub preferencje podczas sesji (np. "Wolę async/await"), aby poprawić spójność i koherencję odpowiedzi.</p>


<h3>Zaawansowane funkcje</h3>

Możesz dodawać specjalne instrukcje dla AI dla konkretnego projektu,
Tworząc plik `GEMINI.md` w katalogu głównym swojego projektu.
Wewnątrz tego pliku możesz zdefiniować zasady projektu,
style kodu i narzędzia, których agent powinien używać. Zapewnia to, że wygenerowany kod jest zgodny ze standardami Twojego projektu.</p>
<p><a href="https://github.com/hypo69/hypotez/blob/master/src/endpoints/hypo69/code_assistant/instructions/CODE_RULES.EN.MD">Przykład instrukcji systemowej</a></p>
<h3>Integracja Google CLI z MCP</h3>
<p>W przypadku większości codziennych zadań wbudowane narzędzia będą wystarczające. Ale co, jeśli chcesz, aby Gemini CLI robiło coś wysoce wyspecjalizowanego, na przykład wchodziło w interakcje z określonymi interfejsami API lub używało wyspecjalizowanego modelu (powiedzmy, generatora obrazów lub narzędzia do analizy bezpieczeństwa)? Właśnie tutaj wkracza MCP (Model Context Protocol).</p>
<p>Zasadniczo MCP to otwarty standard, który pozwala programistom dodawać nowe narzędzia i możliwości do AI poprzez uruchomienie serwera, z którym CLI może się komunikować. W Gemini CLI możesz skonfigurować "serwery MCP" w pliku ustawień JSON, a CLI będzie traktować je jako dodatkowe narzędzia, których może używać.</p>
<h4>Jak skonfigurować serwer MCP w Google CLI</h4>
<p>Jako przykład pokażę, jak skonfigurować serwer MCP dla GitHuba w Gemini CLI.</p>
<p>W folderze projektu utwórz folder za pomocą polecenia:</p>
<pre class="line-numbers"><code class="language-bash">mkdir -p .gemini && touch .gemini/settings.json
</code></pre>
<p>Wypełnij plik tym kodem:
```json
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": { "GITHUB_PERSONAL_ACCESS_TOKEN": "[YOUR-TOKEN]" }
    }
  }
}
```
<p><a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic">instrukcje, jak uzyskać token</a><br>
Następnie wpisz `/quit` w Gemini CLI, aby wyjść, a następnie otwórz go ponownie.
Zobaczysz, że serwer MCP GitHuba działa i jest gotowy do użycia.</p>
<p><img src="assets/gemini_cli_1/mcp.png" alt="MCP"></p>
<p>Wpisz polecenie `/mcp`, a zobaczysz listę narzędzi GitHuba.</p>
<p><img src="assets/gemini_cli_1/mcp_commands.png" alt="Mcp Commands"></p>