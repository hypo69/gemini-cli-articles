## Gemini CLI: Wprowadzenie i pierwsze kroki.

**Gemini CLI** to narzędzie, które działa bezpośrednio w Twoim terminalu, rozumie Twoją bazę kodu i pomaga naprawiać błędy za pomocą zapytań w języku naturalnym. Jest to odpowiedź Google na Claude Code od Anthropic.
Możesz używać Gemini 2.5 Pro (po osiągnięciu limitu narzędzie przełączy się na Gemini 2.5 Flash) i jego okna kontekstowego o pojemności 1 miliona tokenów, aby wykonywać do 60 zapytań na minutę i 1000 zapytań dziennie, a wszystko to za darmo.

### Spis treści
*   Zrozumienie i nawigacja po dużych bazach kodu
*   Wykrywanie i naprawianie błędów
*   Pisanie i testowanie kodu
*   Narzędzia Gemini CLI
*   Integracja Google CLI z MCP

### Kluczowe możliwości Gemini CLI:
*   **Edycja i refaktoryzacja:** Automatycznie ulepsza i upraszcza Twój kod pod kierunkiem AI.
*   **Wykrywanie i naprawianie błędów:** Znajduje błędy i proponuje poprawki.
*   **Zrozumienie kodu:** Gemini CLI może podsumować architekturę, wyjaśnić role modułów lub zbudować mapy przepływu wykonania.
*   **Generowanie testów:** Automatycznie tworzy zadania testowe dla `pytest`.
*   **Wsparcie dokumentacji:** Możesz tworzyć ustrukturyzowane dokumenty Markdown, listy zmian (changelogi) i odpowiedzi na problemy GitHub bezpośrednio w terminalu.
*   **Wykonywanie poleceń:** Gemini CLI może wykonywać polecenia powłoki, takie jak `git`, `npm`, `pip` i inne, co pozwala zarządzać projektami bez wychodzenia z CLI.

---

### Krok 1: Wymagania wstępne

Na początek zainstaluj Node.js (wersja 18 lub wyższa). Możesz pobrać instalator według własnego wyboru lub wykonać następujące polecenia bash w swoim terminalu:

```bash
# Pobieranie i instalacja nvm (Node Version Manager):
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash

# Inicjalizacja nvm w bieżącej sesji terminala
. "$HOME/.nvm/nvm.sh"

# Pobieranie i instalacja Node.js (np. wersji 22):
nvm install 22

# Sprawdzenie wersji Node.js:
node -v # Powinno wyświetlić "v22.17.0" lub podobne

# Sprawdzenie wersji npm:
npm -v # Powinno wyświetlić "10.9.2" lub podobne
```

> ⚠️ **Ważne dla użytkowników Windows:**
> Powyższe polecenie `nvm` jest przeznaczone dla **Linux/macOS** i **nie będzie działać w PowerShell ani cmd.exe**.
> Dla Windows użyj [nvm-windows](https://github.com/coreybutler/nvm-windows), pobierając `nvm-setup.exe` z sekcji [Releases](https://github.com/coreybutler/nvm-windows/releases).
> Alternatywnie możesz zainstalować WSL (Windows Subsystem for Linux) i wykonać polecenia w Ubuntu lub innej dystrybucji Linuksa.

---
### Krok 2: Konfiguracja Gemini CLI

#### Krok 2.1: Instalacja Gemini CLI
Gdy Node.js i npm są zainstalowane i sprawdzone, zainstaluj Gemini CLI, wykonując następujące polecenie w swoim terminalu:
```bash
npx https://github.com/google-gemini/gemini-cli
```
Lub użyj `npm` do globalnej instalacji:
```bash
npm install -g @google/gemini-cli
gemini
```
Po instalacji wpisz `gemini` w terminalu, aby uzyskać dostęp do narzędzia.

#### Krok 2.2: Uwierzytelnianie
Możesz użyć swojego osobistego konta Google do uwierzytelnienia. Zapewni to do 60 zapytań na minutę i 1000 zapytań dziennie podczas korzystania z Gemini.
![First Run](assets/gemini_cli_1/auth.png)

W tym przewodniku użyłem **Logowania przez Google**, ale możesz również użyć **klucza API** (ustawionego jako zmienna środowiskowa lub w pliku `.env`) lub uwierzytelniania przez **Vertex AI**.

Aby wygenerować nowy klucz API, zaloguj się do **AI Studio** za pomocą swojego konta Google i kliknij "Utwórz klucz API".
```bash
# Ustawienie klucza jako zmiennej środowiskowej
export GEMINI_API_KEY="Twój_Klucz_API"

# Lub utwórz plik .env
GEMINI_API_KEY="Twój_Klucz_API"
```
Możesz użyć polecenia `/auth` w polu tekstowym, aby w razie potrzeby przełączyć metodę uwierzytelniania.

---

### Krok 3: Konfiguracja projektu w Gemini CLI
![Start](assets/gemini_cli_1/start.png)
Gdy CLI jest uruchomione, możemy rozpocząć interakcję z Gemini z terminala. Istnieją dwa sposoby pracy z projektem.

#### 1. Rozpoczęcie nowego projektu
Aby rozpocząć projekt od zera, wykonaj następujące polecenia:
```bash
cd new-project/
gemini
```
Wewnątrz CLI użyj promptu, aby rozwiązać interesujący Cię problem, na przykład:
> Napisz kod enkodera dla transformera od podstaw.
![Example 1](assets/gemini_cli_1/example_1.png)
Udziel pozwolenia na zapis plików:
![File](assets/gemini_cli/file.png)

#### 2. Praca z istniejącym projektem
Jeśli masz już bazę kodu, możesz z nią pracować, wykonując następujące polecenia:
```bash
git clone https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo
cd Google-Agent-Development-Kit-Demo
gemini
```
Wewnątrz CLI użyj promptu, na przykład:
> Przedstaw mi podsumowanie wszystkich zmian wprowadzonych w bazie kodu w ciągu ostatniego miesiąca.

---

### Krok 4: Eksperymenty z Gemini CLI
Jako przykład użyję projektu **[Planer podróży 🌍🛫 oparty na ADK](https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo)**.
Za pomocą Gemini CLI pokażę, jak:
1.  badać bazę kodu
2.  wykryć błąd lub problem na GitHubie lub w pliku
3.  przeprowadzić refaktoryzację kodu i wygenerować testy jednostkowe
4.  utworzyć raport Markdown o wprowadzonych zmianach
5.  wizualizować bazę kodu, generując schemat blokowy

#### Badanie i zrozumienie bazy kodu
Zacznijmy od poproszenia Gemini o zbadanie i wyjaśnienie bazy kodu.

**Prompt:** `Zbadaj bieżący katalog i opisz architekturę projektu.`

Gemini CLI zwróci ustrukturyzowane podsumowanie wyjaśniające architekturę:
*   **Interfejs użytkownika:** Aplikacja Streamlit (`travel_ui.py`) zapewnia interfejs do interakcji.
*   **Orkiestracja:** `host_agent` działa jako centralny koordynator.
*   **Wyspecjalizowani agenci:** `flight_agent`, `stay_agent`, `activities_agent` do wyszukiwania lotów, hoteli i rozrywek.
*   **Komunikacja:** Agenci komunikują się ze sobą za pośrednictwem RESTful API w FastAPI.
*   **Wspólne komponenty:** `shared/schemas.py` definiuje wspólne struktury danych.

Pomoże to zorientować się bez ręcznego czytania każdego pliku.

#### Analiza i naprawa problemu na GitHubie
Zbadajmy niektóre otwarte problemy z repozytorium GitHub.

**Prompt:** `Oto problem na GitHubie: [@search https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo/issues/1]. Przeanalizuj bazę kodu i zaproponuj 3-etapowy plan naprawy. Jakie pliki/funkcje należy zmienić?`

Gemini CLI zbadał problem:
*   Używając funkcji `@search`, pobrał dane z GitHuba.
*   Zidentyfikował główną przyczynę jako błąd serializacji JSON (w tym przypadku asynchroniczna funkcja `create_session()` nie została wywołana z `await`).
*   Zaproponował zmiany i obsługę odpowiedzi w kilku plikach.

Następnie CLI oczekuje na dane wejściowe od użytkownika w celu oceny zmian. Jeśli użytkownik się zgodzi, wprowadzi proponowane zmiany.

#### Wdrożenie i testowanie poprawki
Teraz wdrożymy i przetestujemy poprawki zaproponowane przez Gemini.

**Prompt:** `Napisz test jednostkowy dla tej zmiany w pytest w pliku test_shared.py.`

Gemini CLI:
*   Wstawił `json.dumps()` przed wysłaniem ładunku zadania.
*   Utworzył `test_agents.py` w celu dodania testów jednostkowych.
*   Dodał nowy przypadek testowy do sprawdzania schematu i przekazywania zagnieżdżonych wiadomości agentów.

#### Generowanie dokumentacji
Teraz, gdy poprawki zostały wprowadzone, podsumujmy zmiany i zapiszmy je w Markdown w pliku `.txt`.

**Prompt:** `Napisz podsumowanie Markdown dotyczące błędu, poprawki i pokrycia testowego. Sformatuj to jako wpis w dzienniku zmian pod wersją "v0.2.0".`

Następnie, aby zapisać podsumowanie w dokumencie, użyłem następującego promptu:

**Prompt:** `Zapisz to podsumowanie w pliku .txt i nazwij go summary.txt`

Gemini CLI używa narzędzia `WriteFile` do zapisania pliku `summary.txt` w katalogu projektu.

#### Generowanie schematu blokowego za pomocą MCP
Ta sekcja rozszerza poprzednie eksperymenty, w których badam, jak Gemini CLI używa **Model Context Protocol (MCP)** do utrzymywania podsumowań na poziomie plików i historii zadań między promptami. Daje to Gemini "pamięć roboczą" w ramach sesji.

**Prompt:** `Wygeneruj schemat blokowy, który pokazuje, jak agenci komunikują się za pośrednictwem A2A (agent-to-agent) i jak main.py zarządza systemem. Podkreśl, gdzie wystąpił problem i jak został naprawiony.`

Ta wizualizacja stała się możliwa dzięki stałej pamięci Gemini, która zachowała pełny kontekst naszej poprzedniej poprawki błędu i struktury agenta bez konieczności ponownego ładowania plików.

### Dostępne narzędzia Gemini CLI
Wywołanie polecenia `/tools` w Gemini CLI pokaże listę dostępnych narzędzi, które można wykorzystać do wykonywania różnych zadań, takich jak edycja kodu, generowanie testów, tworzenie dokumentacji i wiele innych.
![Tools](assets/gemini_cli_1/tools.png)

**ReadFolder (ls)**
Wyświetla pliki i foldery w katalogu — analogicznie do polecenia `ls` w wierszu poleceń.

**ReadFile (read-file)**
Odczytuje pełną zawartość jednego pliku, co jest przydatne do tworzenia podsumowań lub analizy.

**ReadManyFiles (read-many-files)**
Odczytuje wiele plików jednocześnie, zazwyczaj według wzorca (np. wszystkie pliki `.js`).

**FindFiles (glob)**
Wyszukuje pliki według wzorca (np. znajdź wszystkie pliki `config.json` w swoim projekcie).

**SearchText (grep)**
Wyszukuje tekst w plikach, np. w celu znalezienia wszystkich komentarzy `TODO`.

**Edit (edit)**
Stosuje zmiany w kodzie za pomocą `diff`. Gemini pokazuje podgląd poprawek i prosi o potwierdzenie przed ich zastosowaniem.

**WriteFile (write-file)**
Tworzy nowe pliki (np. `README.md`) z treścią dostarczoną przez użytkownika.

**Shell (shell)**
Wykonuje polecenia bezpośrednio w terminalu, jeśli dodasz przed nimi prefiks `!` (np. `!npm test`).

**WebFetch (web-fetch)**
Pobiera zawartość z sieci (HTML lub JSON), umożliwiając Gemini analizowanie danych zewnętrznych.

**GoogleSearch (web-search)**
Pobiera zawartość z sieci (HTML lub JSON), umożliwiając Gemini analizowanie danych zewnętrznych.

**Save Memory (memoryTool)**
Zapisuje fakty lub preferencje podczas sesji (np. „wolę async/await”), aby poprawić spójność i zgodność odpowiedzi.

### Rozszerzone możliwości

Możesz dodawać specjalne instrukcje dla AI dla konkretnego projektu, tworząc plik `GEMINI.md` w katalogu głównym swojego projektu. Wewnątrz tego pliku możesz definiować reguły projektu, style kodu i narzędzia, których powinien używać agent. Gwarantuje to, że wygenerowany kod jest zgodny ze standardami Twojego projektu.

[Przykład instrukcji systemowej](https://github.com/hypo69/hypotez/blob/master/src/endpoints/hypo69/code_assistant/instructions/CODE_RULES.EN.MD)

### Integracja Google CLI z MCP

Dla większości codziennych zadań wystarczą wbudowane narzędzia. Ale co, jeśli chcesz, aby Gemini CLI robił coś wysoce wyspecjalizowanego, na przykład wchodził w interakcje z określonymi API lub używał wyspecjalizowanego modelu (powiedzmy, generatora obrazów lub narzędzia do analizy bezpieczeństwa)? Właśnie tutaj z pomocą przychodzi MCP (protokół kontekstu modelu).

Zasadniczo MCP to otwarty standard, który pozwala programistom dodawać nowe narzędzia i możliwości do AI poprzez uruchomienie serwera, z którym CLI może wchodzić w interakcje. W Gemini CLI możesz skonfigurować „serwery MCP” w pliku ustawień JSON, a CLI będzie traktować je jako dodatkowe narzędzia, których może używać.

#### Jak skonfigurować serwer MCP w Google CLI

Jako przykład pokażę Ci, jak skonfigurować serwer MCP dla GitHuba w Gemini CLI.

Wewnątrz folderu swojego projektu utwórz folder za pomocą polecenia:

```bash
mkdir -p .gemini && touch .gemini/settings.json
```

Zapisz ten kod w pliku:
```json
{  
  "mcpServers": {  
    "github": {  
      "command": "npx",  
      "args": ["-y", "@modelcontextprotocol/server-github"],  
      "env": { "GITHUB_PERSONAL_ACCESS_TOKEN": "[TWÓJ-TOKEN]" }  
    }  
  }  
}
```
[instrukcja jak uzyskać token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic)

Następnie wpisz `/quit` w Gemini CLI, aby wyjść, a następnie otwórz go ponownie.

Zobaczysz, że serwer MCP GitHub jest uruchomiony i gotowy do użycia.
![MCP](assets/gemini_cli_1/mcp.png)

Wpisz polecenie `/mcp`, a zobaczysz listę narzędzi GitHub.
![Mcp Commands](assets/gemini_cli_1/mcp_commands.png)