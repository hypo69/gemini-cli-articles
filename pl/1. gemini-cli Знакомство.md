## Gemini CLI: Wprowadzenie i pierwsze kroki.

**Gemini CLI** to narzędzie, które działa bezpośrednio w Twoim terminalu, rozumie Twoją bazę kodu i pomaga naprawiać błędy za pomocą zapytań w języku naturalnym. To odpowiedź Google na Claude Code firmy Anthropic.
Możesz używać Gemini 2.5 Pro (narzędzie przełączy się na Gemini 2.5 Flash po osiągnięciu limitu) i jego okna kontekstowego o pojemności 1 miliona tokenów, aby wykonywać do 60 zapytań na minutę i 1000 zapytań dziennie, a wszystko to za darmo.

### Spis treści
*   Zrozumienie i nawigacja po dużych bazach kodu
*   Wykrywanie i naprawianie błędów
*   Pisanie i testowanie kodu
*   Narzędzia Gemini CLI
*   Integracja Google CLI z MCP

### Kluczowe funkcje Gemini CLI:
*   **Edycja i refaktoryzacja:** Automatycznie poprawia i upraszcza Twój kod pod kierunkiem AI.
*   **Wykrywanie i naprawianie błędów:** Znajduje błędy i sugeruje poprawki.
*   **Zrozumienie kodu:** Gemini CLI może podsumować architekturę, wyjaśnić role modułów lub zbudować mapy przepływu wykonania.
*   **Generowanie testów:** Automatycznie tworzy przypadki testowe dla `pytest`
*   **Wsparcie dokumentacji:** Możesz tworzyć ustrukturyzowane dokumenty Markdown, dzienniki zmian (changelogi) i odpowiadać na problemy GitHub bezpośrednio w terminalu.
*   **Wykonywanie poleceń:** Gemini CLI może wykonywać polecenia powłoki, takie jak `git`, `npm`, `pip` i inne, co pozwala zarządzać projektami bez wychodzenia z CLI.

---

### Krok 1: Wymagania wstępne

Aby rozpocząć, zainstaluj Node.js (wersja 18 lub nowsza). Możesz pobrać instalator według własnego wyboru lub uruchomić następujące polecenia bash w swoim terminalu:

```bash
# Pobieranie i instalacja nvm (Node Version Manager):
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash

# Inicjalizacja nvm w bieżącej sesji terminala
. "$HOME/.nvm/nvm.sh"

# Pobieranie i instalacja Node.js (np. wersja 22):
nvm install 22

# Sprawdzenie wersji Node.js:
node -v # Powinno wyświetlić "v22.17.0" lub podobne

# Sprawdzenie wersji npm:
npm -v # Powinno wyświetlić "10.9.2" lub podobne
```

> ⚠️ **Ważne dla użytkowników Windows:**
> Powyższe polecenie `nvm` jest przeznaczone dla **Linux/macOS** i **nie będzie działać w PowerShell ani cmd.exe**.
> Dla systemu Windows użyj [nvm-windows](https://github.com/coreybutler/nvm-windows), pobierając `nvm-setup.exe` z sekcji [Releases](https://github.com/coreybutler/nvm-windows/releases).
> Alternatywnie możesz zainstalować WSL (Windows Subsystem for Linux) i uruchomić polecenia w Ubuntu lub innej dystrybucji Linuksa.

---
### Krok 2: Konfiguracja Gemini CLI

#### Krok 2.1: Instalacja Gemini CLI
Po zainstalowaniu i zweryfikowaniu Node.js i npm, zainstaluj Gemini CLI, uruchamiając następujące polecenie w swoim terminalu:

```bash
npx https://github.com/google-gemini/gemini-cli
```
Lub użyj `npm` do globalnej instalacji:
```bash
npm install -g @google/gemini-cli
gemini
```
Po instalacji wpisz `gemini` w terminalu, aby uzyskać dostęp do narzędzia.

#### Krok 2.2: Uwierzytelnianie
Możesz użyć swojego osobistego konta Google do uwierzytelniania. Zapewni to do 60 zapytań na minutę i 1000 zapytań dziennie podczas korzystania z Gemini.
![First Run](assets/gemini_cli_1/auth.png)

W tym przewodniku użyłem **Zaloguj się przez Google**, ale możesz również użyć **klucza API** (ustawionego jako zmienna środowiskowa lub w pliku `.env`) lub uwierzytelniania **Vertex AI**.

Aby wygenerować nowy klucz API, zaloguj się do **AI Studio** za pomocą swojego konta Google i kliknij "Utwórz klucz API".
```bash
# Ustaw klucz jako zmienną środowiskową
export GEMINI_API_KEY="Your_API_Key"

# Lub utwórz plik .env
GEMINI_API_KEY="Your_API_Key"
```
Możesz użyć polecenia `/auth` w polu tekstowym, aby w razie potrzeby przełączyć metody uwierzytelniania.

---

### Krok 3: Konfiguracja projektu w Gemini CLI
![Start](assets/gemini_cli_1/start.png)
Po uruchomieniu CLI możemy rozpocząć interakcję z Gemini z terminala. Istnieją dwa sposoby pracy z projektem.

#### 1. Rozpocznij nowy projekt
Aby rozpocząć projekt od zera, uruchom następujące polecenia:
```bash
cd new-project/
gemini
```
Wewnątrz CLI użyj monitu, aby rozwiązać interesujący Cię problem, na przykład:
> Napisz kod kodera dla transformatora od podstaw.
![Example 1](assets/gemini_cli_1/example_1.png)
Udziel pozwolenia na zapisywanie plików:
![File](assets/gemini_cli/file.png)

#### 2. Pracuj z istniejącym projektem
Jeśli masz już bazę kodu, możesz z nią pracować, uruchamiając następujące polecenia:
```bash
git clone https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo
cd Google-Agent-Development-Kit-Demo
gemini
```
Wewnątrz CLI użyj monitu, na przykład:
> Podaj mi podsumowanie wszystkich zmian wprowadzonych w bazie kodu w ciągu ostatniego miesiąca.

---

### Krok 4: Eksperymentowanie z Gemini CLI
Jako przykład użyję projektu **[Planer podróży oparty na ADK 🌍🛫](https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo)**.
Z Gemini CLI pokażę, jak:
1.  przeglądać bazę kodu
2.  wykrywać błędy lub problemy na GitHubie lub w pliku
3.  refaktoryzować kod i generować testy jednostkowe
4.  tworzyć raport Markdown z wprowadzonych zmian
5.  wizualizować bazę kodu, generując schemat blokowy

#### Przeglądanie i zrozumienie bazy kodu
Zacznijmy od poproszenia Gemini o przejrzenie i wyjaśnienie bazy kodu.

**Monit:** `Przeglądaj bieżący katalog i opisz architekturę projektu.`

Gemini CLI zwróci ustrukturyzowane podsumowanie wyjaśniające architekturę:
*   **Interfejs użytkownika:** Aplikacja Streamlit (`travel_ui.py`) zapewnia interfejs do interakcji.
*   **Orkiestracja:** `host_agent` działa jako centralny koordynator.
*   **Wyspecjalizowani agenci:** `flight_agent`, `stay_agent`, `activities_agent` do wyszukiwania lotów, hoteli i atrakcji.
*   **Komunikacja:** Agenci komunikują się ze sobą za pośrednictwem interfejsu API RESTful FastAPI.
*   **Wspólne komponenty:** `shared/schemas.py` definiuje wspólne struktury danych.

Pomoże to w nawigacji bez ręcznego czytania każdego pliku.

#### Analiza i naprawa problemu GitHub
Przyjrzyjmy się kilku otwartym problemom z repozytorium GitHub.

**Monit:** `Oto problem GitHub: [@search https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo/issues/1]. Przeanalizuj bazę kodu i zaproponuj 3-etapowy plan naprawy. Które pliki/funkcje należy zmienić?`

Gemini CLI zbadał problem:
*   Korzystając z funkcji `@search`, pobrał dane z GitHuba.
*   Zidentyfikował główną przyczynę jako błąd serializacji JSON (w tym przypadku asynchroniczna funkcja `create_session()` nie została wywołana z `await`).
*   Zaproponował zmiany i obsługę odpowiedzi w wielu plikach.

Następnie CLI czeka na dane wejściowe użytkownika w celu oceny zmian. Jeśli użytkownik się zgodzi, zastosuje sugerowane zmiany.

#### Implementacja i testowanie poprawki
Teraz zaimplementujmy i przetestujmy poprawki sugerowane przez Gemini.

**Monit:** `Napisz test jednostkowy dla tej zmiany w pytest w pliku test_shared.py.`

Gemini CLI:
*   Wstawił `json.dumps()` przed wysłaniem ładunku zadania.
*   Utworzył `test_agents.py`, aby dodać testy jednostkowe.
*   Dodał nowy przypadek testowy, aby sprawdzić schemat i przekazać zagnieżdżone wiadomości agentów.

#### Generowanie dokumentacji
Teraz, gdy poprawki zostały zastosowane, podsumujmy zmiany i zapiszmy je w Markdown w pliku `.txt`.

**Monit:** `Napisz podsumowanie Markdown błędu, poprawki i pokrycia testów. Sformatuj je jako wpis w dzienniku zmian pod wersją "v0.2.0".`

Następnie, aby zapisać podsumowanie w dokumencie, użyłem następującego monitu:

**Monit:** `Zapisz to podsumowanie w pliku .txt i nazwij je summary.txt`

Gemini CLI używa narzędzia `WriteFile` do zapisania pliku `summary.txt` w katalogu projektu.

#### Generowanie schematu blokowego za pomocą MCP
Ta sekcja rozszerza poprzednie eksperymenty, w których badam, w jaki sposób Gemini CLI wykorzystuje **Model Context Protocol (MCP)** do utrzymywania podsumowań na poziomie plików i historii zadań między monitami. Daje to Gemini "pamięć roboczą" w ramach sesji.

**Monit:** `Wygeneruj schemat blokowy, który pokazuje, jak agenci komunikują się za pośrednictwem A2A (agent-to-agent) i jak main.py zarządza systemem. Podkreśl, gdzie wystąpił problem i jak został naprawiony.`

Ta wizualizacja była możliwa dzięki trwałej pamięci Gemini, która zachowała pełny kontekst naszej poprzedniej poprawki błędu i struktury agenta bez konieczności ponownego ładowania plików.

### Dostępne narzędzia Gemini CLI
Wywołanie polecenia `/tools` w Gemini CLI wyświetli listę dostępnych narzędzi, które można wykorzystać do wykonywania różnych zadań, takich jak edycja kodu, generowanie testów, tworzenie dokumentacji i wiele innych.
![Tools](assets/gemini_cli_1/tools.png)

**ReadFolder (ls)**
Wyświetla listę plików i folderów w katalogu — podobnie jak polecenie `ls` w wierszu poleceń.

**ReadFile (read-file)**
Odczytuje pełną zawartość pojedynczego pliku, przydatne do tworzenia podsumowań lub analizy.

**ReadManyFiles (read-many-files)**
Odczytuje wiele plików jednocześnie, zazwyczaj według wzorca (np. wszystkie pliki `.js`).

**FindFiles (glob)**
Wyszukuje pliki według wzorca (np. znajdź wszystkie pliki `config.json` w swoim projekcie).

**SearchText (grep)**
Wyszukuje tekst w plikach, na przykład, aby znaleźć wszystkie komentarze `TODO`.

**Edit (edit)**
Stosuje zmiany w kodzie za pomocą `diff`. Gemini wyświetla podgląd edycji i prosi o potwierdzenie przed ich zastosowaniem.

**WriteFile (write-file)**
Tworzy nowe pliki (np. `README.md`) z treścią dostarczoną przez użytkownika.

**Shell (shell)**
Wykonuje polecenia bezpośrednio w terminalu, jeśli poprzedzisz je prefiksem `!` (np. `!npm test`).

**WebFetch (web-fetch)**
Pobiera zawartość z sieci (HTML lub JSON), umożliwiając Gemini analizowanie danych zewnętrznych.

**GoogleSearch (web-search)**
Wykonuje wyszukiwanie w Google, aby oprzeć odpowiedzi na rzeczywistych informacjach (np. aby znaleźć wyjaśnienie błędu).

**Save Memory (memoryTool)**
Zapisuje fakty lub preferencje podczas sesji (np. "Wolę async/await"), aby poprawić spójność i koherencję odpowiedzi.

### Zaawansowane funkcje

Możesz dodawać specjalne instrukcje dla AI dla konkretnego projektu,
Tworząc plik `GEMINI.md` w katalogu głównym swojego projektu.
Wewnątrz tego pliku możesz zdefiniować zasady projektu,
style kodu i narzędzia, których agent powinien używać. Zapewnia to, że wygenerowany kod jest zgodny ze standardami Twojego projektu.

[Przykład instrukcji systemowej](https://github.com/hypo69/hypotez/blob/master/src/endpoints/hypo69/code_assistant/instructions/CODE_RULES.EN.MD)

### Integracja Google CLI z MCP

W przypadku większości codziennych zadań wbudowane narzędzia będą wystarczające. Ale co, jeśli chcesz, aby Gemini CLI robiło coś wysoce wyspecjalizowanego, na przykład wchodziło w interakcje z określonymi interfejsami API lub używało wyspecjalizowanego modelu (powiedzmy, generatora obrazów lub narzędzia do analizy bezpieczeństwa)? Właśnie tutaj wkracza MCP (Model Context Protocol).

Zasadniczo MCP to otwarty standard, który pozwala programistom dodawać nowe narzędzia i możliwości do AI poprzez uruchomienie serwera, z którym CLI może się komunikować. W Gemini CLI możesz skonfigurować "serwery MCP" w pliku ustawień JSON, a CLI będzie traktować je jako dodatkowe narzędzia, których może używać.

#### Jak skonfigurować serwer MCP w Google CLI

Jako przykład pokażę, jak skonfigurować serwer MCP dla GitHuba w Gemini CLI.

W folderze projektu utwórz folder za pomocą polecenia:

```bash
mkdir -p .gemini && touch .gemini/settings.json
```
Wypełnij plik tym kodem:
```json
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": { "GITHUB_PERSONAL_ACCESS_TOKEN": "[YOUR-TOKEN]" }
    }
  }
}
```
[instrukcje, jak uzyskać token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic)
Następnie wpisz `/quit` w Gemini CLI, aby wyjść, a następnie otwórz go ponownie.
Zobaczysz, że serwer MCP GitHuba działa i jest gotowy do użycia.
![MCP](assets/gemini_cli_1/mcp.png)
Wpisz polecenie `/mcp`, a zobaczysz listę narzędzi GitHuba.
![Mcp Commands](assets/gemini_cli_1/mcp_commands.png)
