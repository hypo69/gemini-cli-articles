<h2>Gemini CLI: Zaawansowane techniki i automatyzacja scenariuszy.</h2>
<p>W pierwszej części omówiliśmy podstawy: instalację, uwierzytelnianie i wykonywanie pojedynczych poleceń. Teraz przejdźmy do następnego poziomu. W tej części nauczymy Gemini CLI wykonywać złożone, wieloetapowe scenariusze, które można zapisywać, ponownie wykorzystywać i udostępniać zespołowi. To przekształci narzędzie z prostego asystenta w potężny silnik automatyzacji.</p>
<h3>Mechanizm wykonywania scenariuszy</h3>
<p>Kluczową ideą jest użycie plików <code>.md</code> jako "przepisów" lub "scenariuszy" dla Gemini. W takim pliku opisujemy w języku naturalnym sekwencję działań, które AI ma wykonać.</p>
<p>Aby uruchomić scenariusz, użyjemy wbudowanego narzędzia <code>ReadFile</code>. Po prostu poprosimy Gemini o przeczytanie pliku z instrukcjami i ich wykonanie.</p>
<p><strong>Główne polecenie do uruchomienia dowolnego scenariusza:</strong></p>
<pre><code>&gt; Przeczytaj i wykonaj instrukcje z pliku 'nazwa_scenariusza.md'</code></pre>
<p>Teraz przyjrzyjmy się kilku przydatnym scenariuszom.</p>
<p>Utwórz katalog <code>scenarios</code>.</p>
<pre class="line-numbers"><code class="language-bash">/path/to/gemini-cli &gt; mkdir scenarios</code></pre>
<p>w nim będziemy przechowywać nasze scenariusze.</p>
<h3>Scenariusz: "Audyt repozytorium Git"</h3>
<p>To zadanie jest znane każdemu programiście: przed rozpoczęciem pracy należy sprawdzić bieżący stan projektu. Stwórzmy scenariusz, który to za nas zrobi.</p>
<ol>
<li><strong>W katalogu <code>scenarios</code> utwórz plik <code>git-health-check.md</code></strong> z następującą zawartością:</li>
</ol>
<pre class="line-numbers"><code class="language-markdown">    Jesteś doświadczonym inżynierem Git. Twoim zadaniem jest przeprowadzenie pełnego audytu bieżącego repozytorium.
    
    Wykonaj następujące kroki ściśle według kolejności i poczekaj na moje potwierdzenie dla każdego polecenia:
    
    1.  <strong>Sprawdź status:</strong> Pokaż mi bieżący status repozytorium, aby zobaczyć nieśledzone lub zmodyfikowane pliki. Zasugeruj polecenie `!git status`.
    2.  <strong>Poproś o aktualizacje:</strong> Pobierz najnowsze zmiany z serwera zdalnego, ale ich nie stosuj. Zasugeruj polecenie `!git fetch origin`.
    3.  <strong>Porównaj gałęzie:</strong> Pokaż mi różnicę między moją lokalną gałęzią `main` a zdalną `origin/main`. Zasugeruj polecenie `!git log main..origin/main --oneline`.
    4.  <strong>Znajdź duże pliki:</strong> Znajdź 5 największych plików w projekcie, które nie znajdują się w `.git`. Zasugeruj polecenie `!find . -type f -not -path "./.git/*" -printf "%s %p\n" | sort -rn | head -n 5`.
    5.  <strong>Podsumuj:</strong> Na koniec krótko opisz stan repozytorium na podstawie uzyskanych danych.
    </code></pre>
<ol start="2">
<li><strong>Uruchom scenariusz w Gemini CLI:</strong></li>
</ol>
<pre><code>&gt; Przeczytaj i wykonaj scenariusz 'git-health-check.md'</code></pre>
<p><img src="assets/1.png" alt="1"></p>
<p>W rzeczywistości w tym katalogu nie ma repozytorium, Gemini zasugeruje utworzenie nowego repozytorium.
Gemini CLI będzie samodzielnie naprawiać błędy podczas tworzenia repozytorium, na przykład, jeśli zapomniałeś je zainicjować, zasugeruje to, 
a także bieżące błędy podczas wykonywania scenariusza.</p>
<h2>Krok 1: Sprawdzenie statusu</h2>
<p><img src="assets/2.png" alt="2"></p>
<p>Odpowiedź Gemini:
<pre class="line-numbers"><code class="language-text">&gt;✦ Jestem doświadczonym inżynierem Git. Rozpoczynam audyt Twojego repozytorium.
&gt; Krok 1: Sprawdzenie statusu
&gt;Aby sprawdzić bieżący status repozytorium i zobaczyć nieśledzone lub zmodyfikowane pliki, wykonam polecenie `git status`.</code></pre>
<p>Wykonanie polecenia `git status`...</p>
<p><img src="assets/3.png" alt="3"></p>
<p>Odpowiedź Gemini:
<pre class="line-numbers"><code class="language-text">✦ Błąd: C:\Users\user\Documents\repos nie jest repozytorium Git.

  Proszę wskazać, w którym z podkatalogów powinienem uruchomić audyt. Na przykład, public_repositories.</code></pre>
<p>Prosimy o utworzenie nowego repozytorium.</p>
<p><img src="assets/4.png" alt="4"></p>
<p>Odpowiedź Gemini:
<pre class="line-numbers"><code class="language-text">✦ Świetnie, repozytorium Git zostało utworzone. Teraz mogę kontynuować audyt.


  Wykonuję git status, aby sprawdzić obecność nieśledzonych plików.</code></pre>
<p><img src="assets/5.png" alt="5"></p>

...

<p><img src="assets/6.png" alt="6"></p>

Odpowiedź Gemini:
<pre class="line-numbers"><code class="language-text">✦ W repozytorium jest wiele nieśledzonych plików i folderów. Aby kontynuować, muszę dodać je do indeksu. Dodam wszystkie pliki.</code></pre>
<p><img src="assets/7.png" alt="7"></p>
...
<p><img src="assets/8.png" alt="8"></p>

Podczas wykonywania polecenia wystąpił błąd
<pre class="line-numbers"><code class="language-text">error: pathspec 'commit"' did not match any file(s) known to git</code></pre>
<p>Odpowiedź Gemini:
<pre class="line-numbers"><code class="language-text">✦ Wygląda na to, że wystąpił błąd z cudzysłowami w poleceniu. Spróbuję jeszcze raz, używając pojedynczych cudzysłowów dla wiadomości commita.</code></pre>
<p><img src="assets/9.png" alt="9"></p>
<p><img src="assets/10.png" alt="10"></p>
Tym razem się udało!

Odpowiedź Gemini:
<pre class="line-numbers"><code class="language-text">✦ Świetnie, pierwszy commit został pomyślnie utworzony. Teraz usunę tymczasowy plik z wiadomością commita.</code></pre>
<p>Teraz gemini usunie tymczasowy plik z wiadomością commita.</p>
<p>gemini cli kolejno stosuje odpowiednie polecenie ('rm','del')</p>
<p><img src="assets/11.png" alt="11"></p>




<h3>Krok 2: Żądanie aktualizacji</h3>
<p>Ponieważ zdalne repozytorium nie istnieje, gemini cli otrzyma błąd. 
Zauważ, że sama oczekuje błędu.

<p><img src="assets/12.png" alt="12"></p>

<h3>Krok 3: Porównanie gałęzi</h3>
<p>Tutaj również wystąpi błąd, ponieważ gałąź `main` nie istnieje.</p>
<p><img src="assets/13.png" alt="13"></p>
<h3>Krok 4: Wyszukiwanie dużych plików</h3>
<p><img src="assets/14.png" alt="14"></p>
<p>Odpowiedź Gemini:
<pre class="line-numbers"><code class="language-text">Polecenie `find` nie zadziałało, ponieważ w systemie Windows należy użyć `dir`. Gemini samo naprawi błąd i zasugeruje prawidłowe polecenie.

Następnie gemini cli rozważa następujące działania:
✦ THINK: The user wants me to find the 5 largest files in the project.
  The previous command find . -type f -not -path "./.git/*" -printf "%s %p\n" | sort -rn | head -n 5 failed because find, sort, and head
  are not native Windows commands. I need to use a PowerShell equivalent.

   1. Get all files: Get-ChildItem -Recurse -File
   2. Exclude .git directory: Where-Object { $_.FullName -notlike "*\.git\*" }
   3. Sort by size (descending): Sort-Object -Property Length -Descending
   4. Select the top 5: Select-Object -First 5
   5. Format the output: ForEach-Object { "{0} {1}" -f $_.Length, $_.FullName }

  Let's combine these into a single PowerShell command.Wygląda na to, że find i head nie są dostępne w Twoim środowisku Windows. Użyję PowerShell,
  aby wykonać to samo zadanie.
</code></pre>
<p><img src="assets/15.png" alt="15"></p>
<p>Znowu niepowodzenie.</p>
<p>gemini cli nadal zastanawia się, co robić dalej:
<pre class="line-numbers"><code class="language-text">
✦ THINK: The user wants to find the 5 largest files.
  The PowerShell command is still not executing correctly. It seems that the pipe | and special characters are being misinterpreted by the
  shell when passed as a single command string.

  I will try to execute the command by first saving the script to a file and then executing the file with PowerShell.

   1. Create a PowerShell script file (find_large_files.ps1).
   2. The content of the script will be: Get-ChildItem -Recurse -File | Where-Object { $_.FullName -notlike "*\.git\*" } | Sort-Object
      -Property Length -Descending | Select-Object -First 5 | Format-Table Length, FullName -AutoSize
   3. Execute the script using powershell -File find_large_files.ps1.
   4. Delete the script file.Wygląda na to, że przekazywanie złożonych poleceń bezpośrednio do PowerShell powoduje problemy. Utworzę tymczasowy plik skryptu
      PowerShell, wykonam go, a następnie usunę.

</code></pre>
<p><img src="assets/16.png" alt="16"></p>
<p>Tym razem wszystko się udało!</p>
<h3>Krok 5: Podsumowanie</h3>
<p>gemini cli podsumowuje:
<pre class="line-numbers"><code class="language-text"> Stan repozytorium:

   * Repozytorium lokalne: Zainicjowane, i wszystkie pliki w folderze głównym C:\Users\user\Documents\repos zostały dodane do pierwszego commita.
   * Repozytorium zdalne: Nie skonfigurowane. Nie ma zdalnego origin, więc niemożliwe jest pobranie aktualizacji lub porównanie gałęzi.
   * Duże pliki: Znaleziono kilka bardzo dużych plików, głównie w podkatalogach venv i public_repositories. Największe z nich to
     biblioteki .lib i archiwa .zip. Zaleca się dodanie ścieżek zawierających duże pliki binarne (np. venv, *.zip) do pliku .gitignore,
     aby uniknąć ich włączenia do repozytorium.

  Audyt zakończony.
</code></pre>
<p><img src="assets/17.png" alt="17"></p>
<hr>
<h3>Scenariusz: "Czyszczenie środowiska Docker"

Docker z czasem gromadzi wiele niepotrzebnych obrazów, kontenerów i sieci. Ten scenariusz pomoże bezpiecznie wszystko wyczyścić.

1.  <strong>Utwórz plik <code>docker-cleanup.md</code></strong>:

    ```markdown
    Jesteś inżynierem DevOps, odpowiedzialnym za czystość systemu. Twoim zadaniem jest bezpieczne wyczyszczenie środowiska Docker.
    
    Działaj krok po kroku:
    
    1.  <strong>Pokaż uruchomione kontenery:</strong> Najpierw wyświetl listę wszystkich aktywnych kontenerów, abym mógł upewnić się, że nie zatrzymam czegoś ważnego. Zasugeruj `!docker ps`.
    2.  <strong>Zatrzymaj wszystkie kontenery:</strong> Po moim zatwierdzeniu zasugeruj polecenie do zatrzymania WSZYSTKICH uruchomionych kontenerów. Polecenie: `!docker stop $(docker ps -q)`.
    3.  <strong>Globalne czyszczenie:</strong> Teraz wykonaj pełne czyszczenie systemu z "wiszących" (dangling) obrazów, zatrzymanych kontenerów, nieużywanych sieci i pamięci podręcznej kompilacji. Zasugeruj najbezpieczniejsze i najskuteczniejsze polecenie `!docker system prune -af`.
    4.  <strong>Raport:</strong> Po wykonaniu poinformuj, ile miejsca zostało zwolnione, na podstawie danych wyjściowych ostatniego polecenia.
    ```

2.  <strong>Uruchom scenariusz w Gemini CLI:</strong>

    ```
    &gt; Przeczytaj i wykonaj scenariusz czyszczenia Docker z pliku 'docker-cleanup.md'
    ```
<strong>Wynik:</strong> Gemini poprowadzi Cię przez bezpieczny proces czyszczenia, prosząc o potwierdzenie na każdym krytycznym kroku.

---

<h3>Scenariusz: "Uruchamianie aplikacji systemowych" 

Jak pokazano w przykładzie, Gemini doskonale radzi sobie z uruchamianiem aplikacji. Sformalizujmy to w prostym scenariuszu dla systemu Windows.

1.  <strong>Utwórz plik <code>open-windows-tools.md</code></strong>:

    ```markdown
    Jesteś administratorem systemu Windows. Twoim zadaniem jest otwieranie narzędzi systemowych na żądanie.
    
    - Jeśli poproszę o "harmonogram zadań", zasugeruj uruchomienie `!taskschd.msc`.
    - Jeśli poproszę o "edytor rejestru", ostrzeż o niebezpieczeństwie i zasugeruj uruchomienie `!regedit`.
    - Jeśli poproszę o "monitor zasobów", zasugeruj uruchomienie `!resmon`.
    - Jeśli poproszę o "menedżer zadań", zasugeruj uruchomienie `!taskmgr`.
    - Jeśli poproszę o "wiersz polecenia", zasugeruj uruchomienie `!cmd`.
    - Jeśli poproszę o "eksplorator plików", zasugeruj uruchomienie `!explorer`.
    Podobnie dla innych narzędzi.
    ```

2.  <strong>Uruchom scenariusz i wydaj polecenie:</strong>

    ```
    &gt; Użyj instrukcji z 'open-windows-tools.md'. Otwórz harmonogram zadań.
    ```
<strong>Wynik:</strong> Gemini zrozumie kontekst z pliku i Twoje żądanie, a następnie zasugeruje wykonanie potrzebnego polecenia.

> <strong>Odpowiedź Gemini:</strong>
> ```text
> Dobrze, otwieram Harmonogram zadań.
> 
> Wykonać `!taskschd.msc`? (t/n)
> ```
Po potwierdzeniu na ekranie otworzy się standardowe narzędzie systemu Windows.
