## Gemini CLI: Advanced techniques and scenario automation.

In the first part, we covered the basics: installation, authentication, and executing single commands. Now, let's move to a higher level. In this part, we'll make Gemini CLI execute complex, multi-step scenarios that can be saved, reused, and shared with the team. This will transform the tool from a simple assistant into a powerful automation engine.

### Scenario Execution Mechanism

The key idea is to use `.md` files as "recipes" or "scenarios" for Gemini. In such a file, we describe in natural language the sequence of actions that the AI should perform.

To run a scenario, we will use the built-in `ReadFile` tool. We will simply ask Gemini to read the instruction file and execute it.

**Main command to run any scenario:**
```
> Read and execute instructions from the file 'scenario_name.md'
```

Now, let's look at a few useful scenarios.

Create the `scenarios` directory.
```bash
/path/to/gemini-cli > mkdir scenarios
```

We will store our scenarios in it.

### Scenario: "Git Repository Audit"

This task is familiar to every developer: before starting work, you need to check the current state of the project. Let's create a scenario that will do this for us.

1.  **In the `scenarios` directory, create the file `git-health-check.md`** with the following content:

    ```markdown
    You are an experienced Git engineer. Your task is to conduct a full audit of the current repository.
    
    Perform the following steps strictly in order and wait for my confirmation for each command:
    
    1.  **Check Status:** Show me the current status of the repository to see untracked or modified files. Suggest the command `!git status`.
    2.  **Fetch Updates:** Download the latest changes from the remote server, but do not apply them. Suggest the command `!git fetch origin`.
    3.  **Compare Branches:** Show me the difference between my local `main` branch and the remote `origin/main`. Suggest the command `!git log main..origin/main --oneline`.
    4.  **Find Large Files:** Find the 5 largest files in the project that are not in `.git`. Suggest the command `!find . -type f -not -path "./.git/*" -printf "%s %p\n" | sort -rn | head -n 5`.
    5.  **Summarize:** Finally, briefly describe the state of the repository based on the obtained data.
    ```

2.  **Run the scenario in Gemini CLI:**

    ```
    > Read and execute the scenario 'git-health-check.md'
    ```

!(assets/1.png)

In reality, there is no repository in this directory, Gemini will suggest creating a new one.
Gemini CLI will automatically correct errors during repository creation, for example, if you forgot to initialize it, it will suggest doing so,
as well as current errors during scenario execution.

## Step 1: Status Check

!(assets/2.png)

Gemini's response:
```text
>✦ I am an experienced Git engineer. I am starting the audit of your repository.
> Step 1: Status Check
>To check the current status of the repository and see untracked or modified files, I will execute the `git status` command.
```
Executing the `git status` command...
!(assets/3.png)

Gemini's response:
```text
✦ Error: C:\Users\user\Documents\repos is not a Git repository.

  Please specify in which subdirectory I should run the audit. For example, public_repositories.
```
Please create a new repository.
!(assets/4.png)
Gemini's response:
```text
✦ Great, the Git repository has been created. Now I can continue the audit.


  Executing git status to check for untracked files.
```
!(assets/5.png)

...

!(assets/6.png)

Gemini's response:
```text
✦ There are many untracked files and folders in the repository. To continue, I need to add them to the index. I will add all files.
```

!(assets/7.png)
...
!(assets/8.png)

An error occurred during command execution
```text
error: pathspec 'commit"' did not match any file(s) known to git
```
Gemini's response:
```text
✦ It seems there was an error with the quotes in the command. I will try again, using single quotes for the commit message.
```

!(assets/9.png)
!(assets/10.png)
This time it worked!

Gemini's response:
```text
✦ Great, the first commit has been successfully created. Now I will delete the temporary file with the commit message.
```

Now gemini will delete the temporary file with the commit message.

gemini cli sequentially applies the appropriate command ('rm','del')

!(assets/11.png)

### Step 2: Requesting Updates

Since the remote repository does not exist, gemini cli will receive an error.
Note that it expects the error itself.

!(assets/12.png)

### Step 3: Comparing Branches

Here too, an error will occur because the `main` branch does not exist.
!(assets/13.png)

### Step 4: Finding Large Files

!(assets/14.png)
Gemini's response:
```text
The `find` command did not work because on Windows, `dir` should be used. Gemini will correct the error itself and suggest the correct command.

Next, gemini cli considers further actions:
✦ THINK: The user wants me to find the 5 largest files in the project.
  The previous command find . -type f -not -path "./.git/*" -printf "%s %p\n" | sort -rn | head -n 5 failed because find, sort, and head
  are not native Windows commands. I need to use a PowerShell equivalent.

   1. Get all files: Get-ChildItem -Recurse -File
   2. Exclude .git directory: Where-Object { $_.FullName -notlike "*.git\*" }
   3. Sort by size (descending): Sort-Object -Property Length -Descending
   4. Select the top 5: Select-Object -First 5
   5. Format the output: ForEach-Object { "{0} {1}" -f $_.Length, $_.FullName }

  Let's combine this into a single PowerShell command. It seems that find and head are not available in your Windows environment. I will use PowerShell
  to perform the same task.
```
!(assets/15.png)

Failure again.

gemini cli continues to ponder what to do next:
Gemini's response:
```text

✦ THINK: The user wants to find the 5 largest files.
  The PowerShell command is still not executing correctly. It seems that the pipe | and special characters are being misinterpreted by the
  shell when passed as a single command string.

  I will try to execute the command by first saving the script to a file, and then executing the file using PowerShell.

   1. Create a PowerShell script file (find_large_files.ps1).
   2. The content of the script will be: Get-ChildItem -Recurse -File | Where-Object { $_.FullName -notlike "*.git\*" } | Sort-Object
      -Property Length -Descending | Select-Object -First 5 | Format-Table Length, FullName -AutoSize
   3. Execute the script using powershell -File find_large_files.ps1.
   4. Delete the script file. It seems that passing complex commands directly to PowerShell causes problems. I will create a temporary PowerShell script file
      execute it, and then delete it.

```
!(assets/16.png)

This time everything worked!

### Step 5: Summary

gemini cli summarizes:
```text
 Repository state:

   * Local repository: Initialized, and all files in the root folder C:\Users\user\Documents\repos have been added to the first commit.
   * Remote repository: Not configured. No remote origin, so it's impossible to fetch updates or compare branches.
   * Large files: Several very large files were detected, mainly in the venv and public_repositories subdirectories. The largest of them are
     .lib libraries and .zip archives. It is recommended to add paths containing large binary files (e.g., venv, *.zip) to the .gitignore file
     to avoid adding them to the repository.

  Audit complete.
```
!(assets/17.png)

### Scenario: "Docker Environment Cleanup"

Docker accumulates many unnecessary images, containers, and networks over time. This scenario will help clean everything up safely.

1.  **Create the file `docker-cleanup.md`**:

    ```markdown
    You are a DevOps engineer, responsible for system cleanliness. Your task is to safely clean up the Docker environment.
    
    Act step by step:
    
    1.  **Show Running Containers:** First, display a list of all active containers so I can make sure I'm not stopping anything important. Suggest `!docker ps`.
    2.  **Stop All Containers:** After my approval, suggest a command to stop ALL running containers. Command: `!docker stop $(docker ps -q)`.
    3.  **Global Cleanup:** Now, perform a full system cleanup of "dangling" images, stopped containers, unused networks, and build cache. Suggest the safest and most effective command `!docker system prune -af`.
    4.  **Report:** After execution, inform how much space was freed based on the output of the last command.
    ```

2.  **Run the scenario in Gemini CLI:**

    ```
    > Read and execute the Docker cleanup scenario from the file 'docker-cleanup.md'
    ```
**Result:** Gemini will guide you through a safe cleanup process, asking for confirmation at each critical step.

---

### Scenario: "Running System Applications"

As shown in the example, Gemini handles running applications perfectly. Let's formalize this into a simple scenario for the Windows system.

1.  **Create the file `open-windows-tools.md`**:

    ```markdown
    You are a Windows system administrator. Your task is to open system tools on demand.
    
    - If I ask for "Task Scheduler", suggest running `!taskschd.msc`.
    - If I ask for "Registry Editor", warn about the danger and suggest running `!regedit`.
    - If I ask for "Resource Monitor", suggest running `!resmon`.
    - If I ask for "Task Manager", suggest running `!taskmgr`.
    - If I ask for "Command Prompt", suggest running `!cmd`.
    - If I ask for "File Explorer", suggest running `!explorer`.
    Similarly for other tools.
    ```

2.  **Run the scenario and issue a command:**

    ```
    > Use instructions from 'open-windows-tools.md'. Open Task Scheduler.
    ```
**Result:** Gemini will understand the context from the file and your request, and then suggest executing the appropriate command.

> **Gemini's Response:**
> ```text
> Okay, opening Task Scheduler.
>
> Execute `!taskschd.msc`? (y/n)
> ```
After confirmation, the standard Windows tool will open on the screen.
```