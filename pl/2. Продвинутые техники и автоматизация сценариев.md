## Gemini CLI: Zaawansowane techniki i automatyzacja scenariuszy.

W pierwszej części omówiliśmy podstawy: instalację, uwierzytelnianie i wykonywanie pojedynczych poleceń. Teraz przejdźmy do następnego poziomu. W tej części nauczymy Gemini CLI wykonywać złożone, wieloetapowe scenariusze, które można zapisywać, ponownie wykorzystywać i udostępniać zespołowi. To przekształci narzędzie z prostego asystenta w potężny silnik automatyzacji.

### Mechanizm wykonywania scenariuszy

Kluczową ideą jest użycie plików `.md` jako "przepisów" lub "scenariuszy" dla Gemini. W takim pliku opisujemy w języku naturalnym sekwencję działań, które AI ma wykonać.

Aby uruchomić scenariusz, użyjemy wbudowanego narzędzia `ReadFile`. Po prostu poprosimy Gemini o przeczytanie pliku z instrukcjami i ich wykonanie.

**Główne polecenie do uruchomienia dowolnego scenariusza:**
```
> Przeczytaj i wykonaj instrukcje z pliku 'nazwa_scenariusza.md'
```

Teraz przyjrzyjmy się kilku przydatnym scenariuszom.

Utwórz katalog `scenarios`.
```bash
/path/to/gemini-cli > mkdir scenarios
```

w nim będziemy przechowywać nasze scenariusze.


### Scenariusz: "Audyt repozytorium Git"

To zadanie jest znane każdemu programiście: przed rozpoczęciem pracy należy sprawdzić bieżący stan projektu. Stwórzmy scenariusz, który to za nas zrobi.

1.  **W katalogu `scenarios` utwórz plik `git-health-check.md`** z następującą zawartością:

    ```markdown
    Jesteś doświadczonym inżynierem Git. Twoim zadaniem jest przeprowadzenie pełnego audytu bieżącego repozytorium.
    
    Wykonaj następujące kroki ściśle według kolejności i poczekaj na moje potwierdzenie dla każdego polecenia: 
    
    1.  **Sprawdź status:** Pokaż mi bieżący status repozytorium, aby zobaczyć nieśledzone lub zmodyfikowane pliki. Zasugeruj polecenie `!git status`.
    2.  **Poproś o aktualizacje:** Pobierz najnowsze zmiany z serwera zdalnego, ale ich nie stosuj. Zasugeruj polecenie `!git fetch origin`.
    3.  **Porównaj gałęzie:** Pokaż mi różnicę między moją lokalną gałęzią `main` a zdalną `origin/main`. Zasugeruj polecenie `!git log main..origin/main --oneline`.
    4.  **Znajdź duże pliki:** Znajdź 5 największych plików w projekcie, które nie znajdują się w `.git`. Zasugeruj polecenie `!find . -type f -not -path "./.git/*" -printf "%s %p\n" | sort -rn | head -n 5`.
    5.  **Podsumuj:** Na koniec krótko opisz stan repozytorium na podstawie uzyskanych danych.
    ```

2.  **Uruchom scenariusz w Gemini CLI:**

    ```
    > Przeczytaj i wykonaj scenariusz 'git-health-check.md'
    ```

![1](assets/1.png)


W rzeczywistości w tym katalogu nie ma repozytorium, Gemini zasugeruje utworzenie nowego repozytorium.
Gemini CLI będzie samodzielnie naprawiać błędy podczas tworzenia repozytorium, na przykład, jeśli zapomniałeś je zainicjować, zasugeruje to, 
a także bieżące błędy podczas wykonywania scenariusza.

## Krok 1: Sprawdzenie statusu

![2](assets/2.png)

Odpowiedź Gemini:
```text
>✦ Jestem doświadczonym inżynierem Git. Rozpoczynam audyt Twojego repozytorium.
> Krok 1: Sprawdzenie statusu
>Aby sprawdzić bieżący status repozytorium i zobaczyć nieśledzone lub zmodyfikowane pliki, wykonam polecenie `git status`.
```
Wykonanie polecenia `git status`...
![3](assets/3.png)

Odpowiedź Gemini:
```text
✦ Błąd: C:\Users\user\Documents\repos nie jest repozytorium Git.

  Proszę wskazać, w którym z podkatalogów powinienem uruchomić audyt. Na przykład, public_repositories.
```
Prosimy o utworzenie nowego repozytorium.
![4](assets/4.png)
Odpowiedź Gemini:
```text
✦ Świetnie, repozytorium Git zostało utworzone. Teraz mogę kontynuować audyt.


  Wykonuję git status, aby sprawdzić obecność nieśledzonych plików.
```
![5](assets/5.png)

...

![6](assets/6.png)

Odpowiedź Gemini:
```text
✦ W repozytorium jest wiele nieśledzonych plików i folderów. Aby kontynuować, muszę dodać je do indeksu. Dodam wszystkie pliki.
```

![7](assets/7.png)
...
![8](assets/8.png)

Podczas wykonywania polecenia wystąpił błąd
```text 
error: pathspec 'commit"' did not match any file(s) known to git
```
Odpowiedź Gemini:
```text
✦ Wygląda na to, że wystąpił błąd z cudzysłowami w poleceniu. Spróbuję jeszcze raz, używając pojedynczych cudzysłowów dla wiadomości commita.
```

![9](assets/9.png)
![10](assets/10.png)
Tym razem się udało!

Odpowiedź Gemini:
```text
✦ Świetnie, pierwszy commit został pomyślnie utworzony. Teraz usunę tymczasowy plik z wiadomością commita.
```
Teraz gemini usunie tymczasowy plik z wiadomością commita.

gemini cli kolejno stosuje odpowiednie polecenie ('rm','del')

![11](assets/11.png)



### Krok 2: Żądanie aktualizacji
Ponieważ zdalne repozytorium nie istnieje, gemini cli otrzyma błąd. 
Zauważ, że sama oczekuje błędu.

![12](assets/12.png)

### Krok 3: Porównanie gałęzi

Tutaj również wystąpi błąd, ponieważ gałąź `main` nie istnieje.
![13](assets/13.png)

###   Krok 4: Wyszukiwanie dużych plików

![14](assets/14.png)
Odpowiedź Gemini:
```text
Polecenie `find` nie zadziałało, ponieważ w systemie Windows należy użyć `dir`. Gemini samo naprawi błąd i zasugeruje prawidłowe polecenie.

Następnie gemini cli rozważa następujące działania:
✦ THINK: The user wants me to find the 5 largest files in the project.
  The previous command find . -type f -not -path ".\\.git\\*" -printf "%s %p\\n" | sort -rn | head -n 5 failed because find, sort, and head
  are not native Windows commands. I need to use a PowerShell equivalent.

   1. Get all files: Get-ChildItem -Recurse -File
   2. Exclude .git directory: Where-Object { $_.FullName -notlike "*.git\\*" }
   3. Sort by size (descending): Sort-Object -Property Length -Descending
   4. Select the top 5: Select-Object -First 5
   5. Format the output: ForEach-Object { "{0} {1}" -f $_.Length, $_.FullName }

  Let's combine these into a single PowerShell command.Wygląda na to, że find i head nie są dostępne w Twoim środowisku Windows. Użyję PowerShell,
  aby wykonać to samo zadanie.
```
![15](assets/15.png)

Znowu niepowodzenie.

gemini cli nadal zastanawia się, co robić dalej:
```text
 
✦ THINK: The user wants to find the 5 largest files.
  The PowerShell command is still not executing correctly. It seems that the pipe | and special characters are being misinterpreted by the
  shell when passed as a single command string.

  I will try to execute the command by first saving the script to a file and then executing the file with PowerShell.

   1. Create a PowerShell script file (find_large_files.ps1).
   2. The content of the script will be: Get-ChildItem -Recurse -File | Where-Object { $_.FullName -notlike "*.git\\*" } | Sort-Object
      -Property Length -Descending | Select-Object -First 5 | Format-Table Length, FullName -AutoSize
   3. Execute the script using powershell -File find_large_files.ps1.
   4. Delete the script file.Wygląda na to, że przekazywanie złożonych poleceń bezpośrednio do PowerShell powoduje problemy. Utworzę tymczasowy plik skryptu
      PowerShell, wykonam go, a następnie usunę.

```
![16](assets/16.png)

Tym razem wszystko się udało!

### Krok 5: Podsumowanie
gemini cli podsumowuje:
```text
 Stan repozytorium:

   * Repozytorium lokalne: Zainicjowane, i wszystkie pliki w folderze głównym C:\Users\user\Documents\repos zostały dodane do pierwszego commita.
   * Repozytorium zdalne: Nie skonfigurowane. Nie ma zdalnego origin, więc niemożliwe jest pobranie aktualizacji lub porównanie gałęzi.
   * Duże pliki: Znaleziono kilka bardzo dużych plików, głównie w podkatalogach venv i public_repositories. Największe z nich to
     biblioteki .lib i archiwa .zip. Zaleca się dodanie ścieżek zawierających duże pliki binarne (np. venv, *.zip) do pliku .gitignore,
     aby uniknąć ich włączenia do repozytorium.

  Audyt zakończony.
```
![17](assets/17.png)
---


### Scenariusz: "Czyszczenie środowiska Docker"


Docker z czasem gromadzi wiele niepotrzebnych obrazów, kontenerów i sieci. Ten scenariusz pomoże bezpiecznie wszystko wyczyścić.

1.  **Utwórz plik `docker-cleanup.md`**:

    ```markdown
    Jesteś inżynierem DevOps, odpowiedzialnym za czystość systemu. Twoim zadaniem jest bezpieczne wyczyszczenie środowiska Docker.
    
    Działaj krok po kroku: 
    
    1.  **Pokaż uruchomione kontenery:** Najpierw wyświetl listę wszystkich aktywnych kontenerów, abym mógł upewnić się, że nie zatrzymam czegoś ważnego. Zasugeruj `!docker ps`.
    2.  **Zatrzymaj wszystkie kontenery:** Po moim zatwierdzeniu zasugeruj polecenie do zatrzymania WSZYSTKICH uruchomionych kontenerów. Polecenie: `!docker stop $(docker ps -q)`.
    3.  **Globalne czyszczenie:** Teraz wykonaj pełne czyszczenie systemu z "wiszących" (dangling) obrazów, zatrzymanych kontenerów, nieużywanych sieci i pamięci podręcznej kompilacji. Zasugeruj najbezpieczniejsze i najskuteczniejsze polecenie `!docker system prune -af`.
    4.  **Raport:** Po wykonaniu poinformuj, ile miejsca zostało zwolnione, na podstawie danych wyjściowych ostatniego polecenia.
    ```

2.  **Uruchom scenariusz w Gemini CLI:**

    ```
    > Przeczytaj i wykonaj scenariusz czyszczenia Docker z pliku 'docker-cleanup.md'
    ```
**Wynik:** Gemini poprowadzi Cię przez bezpieczny proces czyszczenia, prosząc o potwierdzenie na każdym krytycznym kroku.

---


### Scenariusz: "Uruchamianie aplikacji systemowych"


Jak pokazano w przykładzie, Gemini doskonale radzi sobie z uruchamianiem aplikacji. Sformalizujmy to w prostym scenariuszu dla systemu Windows.

1.  **Utwórz plik `open-windows-tools.md`**:

    ```markdown
    Jesteś administratorem systemu Windows. Twoim zadaniem jest otwieranie narzędzi systemowych na żądanie.

    - Jeśli poproszę o "Task Scheduler", zasugeruj uruchomienie `!taskschd.msc`.
    - Jeśli poproszę o "Registry Editor", ostrzeż o niebezpieczeństwie i zasugeruj uruchomienie `!regedit`.
    - Jeśli poproszę o "Resource Monitor", zasugeruj uruchomienie `!resmon`.
    - Jeśli poproszę o "Task Manager", zasugeruj uruchomienie `!taskmgr`.
    - Jeśli poproszę o "Command Prompt", zasugeruj uruchomienie `!cmd`.
    - Jeśli poproszę o "File Explorer", zasugeruj uruchomienie `!explorer`.
    Podobnie dla innych narzędzi.
    ```

2.  **Uruchom scenariusz i wydaj polecenie:**

    ```
    > Użyj instrukcji z 'open-windows-tools.md'. Otwórz harmonogram zadań.
    ```
**Wynik:** Gemini zrozumie kontekst z pliku i Twoje żądanie, a następnie zasugeruje wykonanie potrzebnego polecenia.

> **Odpowiedź Gemini:**
> ```text
> Dobrze, otwieram Harmonogram zadań.
>
> Wykonać `!taskschd.msc`? (t/n)
> ```
Po potwierdzeniu na ekranie otworzy się standardowe narzędzie systemu Windows.
```