<h3><strong>Scenariusz dla Gemini CLI: Gra "Å»ycie"</strong></h3>
<h4><strong>Krok 1: Tworzenie instrukcji systemowej <code>GEMINI.md</code></strong></h4>
<p>UtwÃ³rz katalog <code>.gemini</code> w folderze roboczym projektu. WewnÄ…trz <code>.gemini</code> utwÃ³rz plik <code>GEMINI.md</code> i wklej do niego instrukcjÄ™ systemowÄ…. PrzykÅ‚ad instrukcji:</p>
<pre class="line-numbers"><code class="language-markdown">## ğŸ“˜ Instrukcja do generowania kodu Python

### 1. OgÃ³lne zasady

* UÅ¼ywaj **Python 3.10+**.
* Przestrzegaj **jasnego, czytelnego i jednoznacznego stylu** kodowania.
* **KaÅ¼da funkcja, metoda i klasa** powinna mieÄ‡:

  * AdnotacjÄ™ typÃ³w (`type hints`)
  * PeÅ‚nÄ… i poprawnÄ… dokumentacjÄ™ w formacie `docstring` (patrz sekcja 3)
  * WewnÄ™trzne komentarze (`#`), gdzie to konieczne

---

### 2. Komentarze

* Komentarze powinny byÄ‡ **precyzyjne** i opisywaÄ‡ **co kod robi**, a nie Â«co robimyÂ».
* **Zabronione** jest uÅ¼ywanie zaimkÃ³w: `robimy`, `zwracamy`, `wysyÅ‚amy`, `przechodzimy` itp.
* **Dozwolone** sÄ… tylko terminy: `ekstrakcja`, `wykonanie`, `wywoÅ‚anie`, `zamiana`, `sprawdzenie`, `wysyÅ‚anie`, `Funkcja wykonuje`, `Funkcja zmienia wartoÅ›Ä‡` itp.

#### âŒ PrzykÅ‚ad niepoprawnego komentarza:

<pre>```python
# Pobieramy wartoÅ›Ä‡ parametru
```

#### âœ… PrzykÅ‚ad poprawnego komentarza:

<pre>```python
# Funkcja ekstrahuje wartoÅ›Ä‡ parametru
```

---

### 3. Docstring (format dokumentacji)

KaÅ¼da funkcja/metoda/klasa powinna zawieraÄ‡ `docstring` w nastÄ™pujÄ…cym formacie:

<pre>```python
def function(param: str, param1: Optional[str | dict | str] = None) -> dict | None:
    """
    Args:
        param (str): Opis parametru `param`.
        param1 (Optional[str | dict | str], optional): Opis parametru `param1`. DomyÅ›lnie `None`.

    Returns:
        dict | None: Opis zwracanej wartoÅ›ci. Zwraca sÅ‚ownik lub `None`.

    Raises:
        SomeError: Opis sytuacji, w ktÃ³rej wystÄ™puje wyjÄ…tek `SomeError`.

    Example:
        >>> function('param', 'param1')
        {'param': 'param1'}
    """
```

* **Wszystkie parametry i zwracane wartoÅ›ci muszÄ… byÄ‡ opisane.**
* SformuÅ‚owania powinny byÄ‡ **zwiÄ™zÅ‚e, precyzyjne i jednoznaczne**.
* Nie wolno pomijaÄ‡ opisu parametrÃ³w/zwracanych wartoÅ›ci/wyjÄ…tkÃ³w.

---

### 4. Adnotacja typÃ³w

* **Wszystkie zmienne, parametry i zwracane wartoÅ›ci** muszÄ… byÄ‡ adnotowane.
* UÅ¼ywaj skÅ‚adni Python 3.10+: `list[int]`, `dict[str, Any]`, `str | None`, itp.
* PrzykÅ‚ady poprawnych adnotacji:

#### âœ… Proste typy:

<pre>```python
name: str = "John"
count: int = 42
flag: bool = True
```

#### âœ… Kolekcje i typy zÅ‚oÅ¼one:

<pre>```python
from typing import Any, Optional, Callable, TypeAlias

coordinates: tuple[float, float] = (55.75, 37.61)
metadata: dict[str, Any] = {"debug": True}
UserId: TypeAlias = int
```

#### âœ… Funkcje i metody:

<pre>```python
def get_user_name(user_id: int) -> str:
    """Zwraca nazwÄ™ uÅ¼ytkownika na podstawie jego identyfikatora."""
    ...
```

#### âœ… Funkcje asynchroniczne:

<pre>```python
async def fetch_users() -> AsyncIterator[dict[str, int | str]]:
    ...
```

#### âœ… Typy generyczne:

<pre>```python
from typing import TypeVar, Generic

T = TypeVar("T")

class Container(Generic[T]):
    def __init__(self, value: T) -> None:
        self.value = value

    def get(self) -> T:
        return self.value
```

---

### 5. Inne

* UÅ¼ywaj `default_factory` w `dataclass` dla wartoÅ›ci zmiennych (`list`, `dict`).
* Dla wartoÅ›ci `Optional` okreÅ›l `T | None` (Python 3.10+) lub `Optional[T]`.
* Dla zÅ‚oÅ¼onych struktur â€” uÅ¼ywaj `TypeAlias`.

---

ğŸ“Œ **WskazÃ³wka:** Przechowywanie `GEMINI.md` w `.gemini` jest standardowÄ… praktykÄ… dla gemini-cli. Podczas generowania kodu zawsze doÅ‚Ä…czaj adnotacjÄ™ typÃ³w, `docstring` i unikaj subiektywnych sformuÅ‚owaÅ„ w komentarzach. Celem jest jak najdokÅ‚adniejsza, odtwarzalna i sformalizowana struktura kodu.

---

Dla wygody utworzymy katalog `game`, w ktÃ³rym bÄ™dÄ… przechowywane pliki projektu, oraz katalog `scenarios`, w ktÃ³rym bÄ™dÄ… przechowywane scenariusze dla Gemini CLI:

* `scenarios/life-create-code.md` â€” instrukcje do tworzenia kodu gry "Å»ycie"
* `scenarios/life-create-test.md` â€” instrukcje do tworzenia testÃ³w
* `scenarios/life-create-doc.md` â€” instrukcje do tworzenia dokumentacji

---

<h3><strong>life-create-code.md</strong></h3>
<pre class="line-numbers"><code class="language-markdown">WewnÄ…trz katalogu `game` utwÃ³rz plik life.py. 
Zaimplementuj "GrÄ™ w Å¼ycie" Conwaya w Pythonie, uÅ¼ywajÄ…c podejÅ›cia obiektowego.
UÅ¼yj bibliotek: `numpy`, `pygame` (do grafiki).

Wymagania:
1.  UtwÃ³rz klasÄ™ `Game`.
2.  W `__init__` klasa powinna przyjmowaÄ‡ wymiary siatki (szerokoÅ›Ä‡, wysokoÅ›Ä‡) i tworzyÄ‡ losowe pole poczÄ…tkowe.
3.  UtwÃ³rz metodÄ™ `step()`, ktÃ³ra aktualizuje stan gry o jeden krok:
    - Å»ywa komÃ³rka z &lt; 2 Å¼ywymi sÄ…siadami umiera (samotnoÅ›Ä‡).
    - Å»ywa komÃ³rka z 2 lub 3 Å¼ywymi sÄ…siadami przeÅ¼ywa.
    - Å»ywa komÃ³rka z &gt; 3 Å¼ywymi sÄ…siadami umiera (przeludnienie).
    - Martwa komÃ³rka z dokÅ‚adnie 3 Å¼ywymi sÄ…siadami staje siÄ™ Å¼ywa (narodziny).
4.  UtwÃ³rz metodÄ™ `display()` lub nadpisz `__str__`, aby wyÅ›wietlaÄ‡ pole w konsoli ('â– ' dla Å¼ywej komÃ³rki, ' ' dla martwej).
5.  UÅ¼yj `numpy` do efektywnej pracy z siatkÄ….
6.  W bloku `if __name__ == '__main__':` dodaj przykÅ‚ad, ktÃ³ry tworzy grÄ™ i uruchamia symulacjÄ™ z niewielkim opÃ³Åºnieniem miÄ™dzy krokami.
7. Do wizualizacji gry uÅ¼yj `pygame` lub innej biblioteki graficznej.
</code></pre>
<hr>
<h3><strong>life-create-test.md</strong></h3>
<pre class="line-numbers"><code class="language-markdown">WewnÄ…trz katalogu `game` utwÃ³rz plik test_life.py, uÅ¼ywajÄ…c kontekstu z pliku @life.py. UÅ¼yj frameworka pytest.

Test powinien sprawdzaÄ‡ ewolucjÄ™ prostego oscylatora "Blinker":

1. Zaimportuj klasÄ™ `Game` z `life`.
2. UtwÃ³rz funkcjÄ™ testowÄ…, na przykÅ‚ad `test_blinker_oscillation`.
3. UtwÃ³rz instancjÄ™ `Game` o staÅ‚ym rozmiarze (na przykÅ‚ad 5x5).
4. RÄ™cznie ustaw poczÄ…tkowy stan pola: poziomÄ… liniÄ™ trzech Å¼ywych komÃ³rek w centrum.
5. WywoÅ‚aj `game.step()`.
6. Za pomocÄ… `assert` i `numpy.array_equal`, sprawdÅº, czy pole zmieniÅ‚o siÄ™ na pionowÄ… liniÄ™ trzech komÃ³rek.
7. WywoÅ‚aj `game.step()` jeszcze raz.
8. SprawdÅº, czy pole wrÃ³ciÅ‚o do pierwotnego stanu poziomego.
</code></pre>
<hr>
<h3><strong>life-create-doc.md</strong></h3>
<pre class="line-numbers"><code class="language-markdown">Przeanalizuj pliki @life.py i @test_life.py wewnÄ…trz katalogu `game` i na ich podstawie utwÃ³rz plik dokumentacji doc.md.

Struktura dokumentacji:
- **TytuÅ‚:** # Projekt "Gra w Å¼ycie"
- **KrÃ³tki opis:** Implementacja automatu komÃ³rkowego Conwaya.
- **Struktura plikÃ³w:** KrÃ³tki opis przeznaczenia plikÃ³w `life.py` i `test_life.py`.
- **Jak uruchomiÄ‡ symulacjÄ™:** Polecenie do uruchomienia pliku gÅ‚Ã³wnego (`python life.py`).
- **Jak uruchomiÄ‡ testy:** Polecenia do instalacji zaleÅ¼noÅ›ci (`pip install pytest numpy`) i uruchomienia testÃ³w (`pytest`).
</code></pre>
<hr>
<h3><strong>Krok 2: Tworzenie kodu gry "Å»ycie"</strong></h3>
<p>Uruchamiamy gemini-cli w terminalu. WaÅ¼ne! Upewnij siÄ™, Å¼e znajdujesz siÄ™ w katalogu, w ktÃ³rym znajduje siÄ™ <code>.gemini/GEMINI.md</code>.</p>
<ol>
<li>Udzielamy pozwolenia na utworzenie pliku.</li>
<li>Gemini CLI wygeneruje plik <code>life.py</code> w katalogu <code>game</code>.</li>
<li>Tworzymy wirtualne Å›rodowisko venv, instalujemy zaleÅ¼noÅ›ci i uruchamiamy grÄ™.</li>
</ol>
<hr>
<h3><strong>Krok 3: Tworzenie testÃ³w</strong></h3>
<ol>
<li>Gemini CLI generuje plik <code>test_life.py</code> w katalogu <code>game</code>.</li>
<li>Testujemy proste scenariusze, na przykÅ‚ad oscylator "Blinker".
<li>W razie potrzeby poprawiamy bÅ‚Ä™dy.</li>
</ol>
<hr>
<h3><strong>Krok 4: Tworzenie dokumentacji</strong></h3>
<ol>
<li>Gemini CLI analizuje <code>life.py</code> i <code>test_life.py</code>.</li>
<li>Generuje plik <code>doc.md</code> z opisem projektu, instrukcjami uruchamiania gry i testÃ³w.</li>
</ol>
<p>Voila! Projekt jest gotowy.</p>
