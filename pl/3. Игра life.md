### **Scenariusz dla Gemini CLI: Gra "Życie"**

#### **Krok 1: Tworzenie instrukcji systemowej `GEMINI.md`**

Utwórz katalog `.gemini` w folderze roboczym projektu. Wewnątrz `.gemini` utwórz plik `GEMINI.md` i wklej do niego instrukcję systemową. Przykład instrukcji:

````markdown
## 📘 Instrukcja do generowania kodu Python

### 1. Ogólne zasady

* Używaj **Python 3.10+**.
* Przestrzegaj **jasnego, czytelnego i jednoznacznego stylu** kodowania.
* **Każda funkcja, metoda i klasa** powinna mieć:

  * Adnotację typów (`type hints`)
  * Pełną i poprawną dokumentację w formacie `docstring` (patrz sekcja 3)
  * Wewnętrzne komentarze (`#`), gdzie to konieczne

---

### 2. Komentarze

* Komentarze powinny być **precyzyjne** i opisywać **co kod robi**, a nie «co robimy».
* **Zabronione** jest używanie zaimków: `robimy`, `zwracamy`, `wysyłamy`, `przechodzimy` itp.
* **Dozwolone** są tylko terminy: `ekstrakcja`, `wykonanie`, `wywołanie`, `zamiana`, `sprawdzenie`, `wysyłanie`, `Funkcja wykonuje`, `Funkcja zmienia wartość` itp.

#### ❌ Przykład niepoprawnego komentarza:

```python
# Pobieramy wartość parametru
````

#### ✅ Przykład poprawnego komentarza:

```python
# Funkcja ekstrahuje wartość parametru
```

---

### 3. Docstring (format dokumentacji)

Każda funkcja/metoda/klasa powinna zawierać `docstring` w następującym formacie:

```python
def function(param: str, param1: Optional[str | dict | str] = None) -> dict | None:
    """
    Args:
        param (str): Opis parametru `param`.
        param1 (Optional[str | dict | str], optional): Opis parametru `param1`. Domyślnie `None`.

    Returns:
        dict | None: Opis zwracanej wartości. Zwraca słownik lub `None`.

    Raises:
        SomeError: Opis sytuacji, w której występuje wyjątek `SomeError`.

    Example:
        >>> function('param', 'param1')
        {'param': 'param1'}
    """
```

* **Wszystkie parametry i zwracane wartości muszą być opisane.**
* Sformułowania powinny być **zwięzłe, precyzyjne i jednoznaczne**.
* Nie wolno pomijać opisu parametrów/zwracanych wartości/wyjątków.

---

### 4. Adnotacja typów

* **Wszystkie zmienne, parametry i zwracane wartości** muszą być adnotowane.
* Używaj składni Python 3.10+: `list[int]`, `dict[str, Any]`, `str | None` itp.
* Przykłady poprawnych adnotacji:

#### ✅ Proste typy:

```python
name: str = "John"
count: int = 42
flag: bool = True
```

#### ✅ Kolekcje i typy złożone:

```python
from typing import Any, Optional, Callable, TypeAlias

coordinates: tuple[float, float] = (55.75, 37.61)
metadata: dict[str, Any] = {"debug": True}
UserId: TypeAlias = int
```

#### ✅ Funkcje i metody:

```python
def get_user_name(user_id: int) -> str:
    """Zwraca nazwę użytkownika na podstawie jego identyfikatora."""
    ...
```

#### ✅ Funkcje asynchroniczne:

```python
async def fetch_users() -> AsyncIterator[dict[str, int | str]]:
    ...
```

#### ✅ Typy generyczne:

```python
from typing import TypeVar, Generic

T = TypeVar("T")

class Container(Generic[T]):
    def __init__(self, value: T) -> None:
        self.value = value

    def get(self) -> T:
        return self.value
```

---

### 5. Inne

* Używaj `default_factory` w `dataclass` dla wartości zmiennych (`list`, `dict`).
* Dla wartości `Optional` określ `T | None` (Python 3.10+) lub `Optional[T]`.
* Dla złożonych struktur — używaj `TypeAlias`.

---

📌 **Wskazówka:** Przechowywanie `GEMINI.md` w `.gemini` jest standardową praktyką dla gemini-cli. Podczas generowania kodu zawsze dołączaj adnotację typów, `docstring` i unikaj subiektywnych sformułowań w komentarzach. Celem jest jak najdokładniejsza, odtwarzalna i sformalizowana struktura kodu.

---

Dla wygody utworzymy katalog `game`, w którym będą przechowywane pliki projektu, oraz katalog `scenarios`, w którym będą przechowywane scenariusze dla Gemini CLI:

* `scenarios/life-create-code.md` — instrukcje do tworzenia kodu gry "Życie"
* `scenarios/life-create-test.md` — instrukcje do tworzenia testów
* `scenarios/life-create-doc.md` — instrukcje do tworzenia dokumentacji

---

### **life-create-code.md**

```markdown
Wewnątrz katalogu `game` utwórz plik life.py. 
Zaimplementuj "Grę w życie" Conwaya w Pythonie, używając podejścia obiektowego.
Użyj bibliotek: `numpy`, `pygame` (do grafiki).

Wymagania:
1.  Utwórz klasę `Game`.
2.  W `__init__` klasa powinna przyjmować wymiary siatki (szerokość, wysokość) i tworzyć losowe pole początkowe.
3.  Utwórz metodę `step()`, która aktualizuje stan gry o jeden krok:
    - Żywa komórka z < 2 żywymi sąsiadami umiera (samotność).
    - Żywa komórka z 2 lub 3 żywymi sąsiadami przeżywa.
    - Żywa komórka z > 3 żywymi sąsiadami umiera (przeludnienie).
    - Martwa komórka z dokładnie 3 żywymi sąsiadami staje się żywa (narodziny).
4.  Utwórz metodę `display()` lub nadpisz `__str__`, aby wyświetlać pole w konsoli ('■' dla żywej komórki, ' ' dla martwej).
5.  Użyj `numpy` do efektywnej pracy z siatką.
6.  W bloku `if __name__ == '__main__':` dodaj przykład, który tworzy grę i uruchamia symulację z niewielkim opóźnieniem między krokami.
7. Do wizualizacji gry użyj `pygame` lub innej biblioteki graficznej.
```

---

### **life-create-test.md**

```markdown
Wewnątrz katalogu `game` utwórz plik test_life.py, używając kontekstu z pliku @life.py. Użyj frameworka pytest.

Test powinien sprawdzać ewolucję prostego oscylatora "Blinker":

1. Zaimportuj klasę `Game` z `life`.
2. Utwórz funkcję testową, na przykład `test_blinker_oscillation`.
3. Utwórz instancję `Game` o stałym rozmiarze (na przykład 5x5).
4. Ręcznie ustaw początkowy stan pola: poziomą linię trzech żywych komórek w centrum.
5. Wywołaj `game.step()`.
6. Za pomocą `assert` i `numpy.array_equal`, sprawdź, czy pole zmieniło się na pionową linię trzech komórek.
7. Wywołaj `game.step()` jeszcze raz.
8. Sprawdź, czy pole wróciło do pierwotnego stanu poziomego.
```

---

### **life-create-doc.md**

```markdown
Przeanalizuj pliki @life.py i @test_life.py wewnątrz katalogu `game` i na ich podstawie utwórz plik dokumentacji doc.md.

Struktura dokumentacji:
- **Tytuł:** # Projekt "Gra w życie"
- **Krótki opis:** Implementacja automatu komórkowego Conwaya.
- **Struktura plików:** Krótki opis przeznaczenia plików `life.py` i `test_life.py`.
- **Jak uruchomić symulację:** Polecenie do uruchomienia pliku głównego (`python life.py`).
- **Jak uruchomić testy:** Polecenia do instalacji zależności (`pip install pytest numpy`) i uruchomienia testów (`pytest`).
```

---

### **Krok 2: Tworzenie kodu gry "Życie"**

Uruchamiamy gemini-cli w terminalu. Ważne! Upewnij się, że znajdujesz się w katalogu, w którym znajduje się `.gemini/GEMINI.md`.

1. Udzielamy pozwolenia na utworzenie pliku.
2. Gemini CLI wygeneruje plik `life.py` w katalogu `game`.
3. Tworzymy wirtualne środowisko venv, instalujemy zależności i uruchamiamy grę.

---

### **Krok 3: Tworzenie testów**

1. Gemini CLI generuje plik `test_life.py` w katalogu `game`.
2. Testujemy proste scenariusze, na przykład oscylator "Blinker".
3. W razie potrzeby poprawiamy błędy.

---

### **Krok 4: Tworzenie dokumentacji**

1. Gemini CLI analizuje `life.py` i `test_life.py`.
2. Generuje plik `doc.md` z opisem projektu, instrukcjami uruchamiania gry i testów.

Voila! Projekt jest gotowy.