Это очень полезный сценарий, который помогает выявить, какие программы активно используют сетевое соединение, что может быть важно для диагностики проблем с производительностью сети или для обнаружения вредоносного ПО.

Скрипт - ответ модели, который получает список активных сетевых соединений и связывает их с соответствующими процессами.

-----

### Скрипт мониторинга сетевых подключений

Этот скрипт использует командлет `Get-NetTCPConnection` для получения информации о текущих сетевых соединениях и `Get-Process` для сопоставления этих соединений с запущенными приложениями.

**Сценарий:** Вы хотите узнать, какие приложения прямо сейчас отправляют или получают данные по сети, чтобы, например, выявить причину замедления интернета.

**Команда, которую можно использовать в Gemini CLI:**

```powershell
gemini-cli "Напиши скрипт PowerShell, который выводит список всех приложений, которые в данный момент используют сеть. Для каждого приложения нужно указать его имя, локальный и удалённый IP-адреса, а также локальный и удалённый порты."
```

**Пример сгенерированного скрипта:**

```powershell
Write-Host "--- Мониторинг сетевых подключений ---" -ForegroundColor Green
Write-Host "Получение списка активных сетевых соединений..." -ForegroundColor Yellow

# Получаем все активные TCP-соединения
$connections = Get-NetTCPConnection | Where-Object { $_.State -eq 'Established' -or $_.State -eq 'SynSent' }

# Создаём пустой массив для хранения информации
$networkApps = @()

if ($connections.Count -eq 0) {
    Write-Host "`nАктивных сетевых соединений не найдено." -ForegroundColor Red
} else {
    foreach ($conn in $connections) {
        # Получаем информацию о процессе по его PID
        $process = Get-Process -Id $conn.OwningProcess -ErrorAction SilentlyContinue

        # Если процесс найден, добавляем его в массив
        if ($process) {
            $networkApps += [PSCustomObject]@{
                ProcessName = $process.ProcessName
                LocalAddress = $conn.LocalAddress
                LocalPort = $conn.LocalPort
                RemoteAddress = $conn.RemoteAddress
                RemotePort = $conn.RemotePort
                State = $conn.State
            }
        }
    }
}

# Сортируем по имени процесса и выводим результат в виде таблицы
if ($networkApps.Count -gt 0) {
    Write-Host "`nНайденные приложения, использующие сеть:`n" -ForegroundColor Cyan
    $networkApps | Sort-Object ProcessName | Format-Table -AutoSize
}

Write-Host "`n--- Мониторинг завершён ---" -ForegroundColor Green
```

### Как это работает?

  * **`Get-NetTCPConnection`**: Это ключевой командлет, который предоставляет информацию о всех TCP-соединениях, включая их локальные и удалённые адреса и порты, а также состояние (`Established`, `Listen` и т.д.).
  * **`OwningProcess`**: Каждое соединение имеет свойство `OwningProcess`, которое содержит идентификатор процесса (PID). Это позволяет нам связать сетевое подключение с конкретным приложением.
  * **`Get-Process -Id $conn.OwningProcess`**: Используя PID из `Get-NetTCPConnection`, мы получаем объект процесса.
  * **`Where-Object`**: Фильтруем соединения, чтобы показывать только те, которые находятся в состоянии `Established` (установлено) или `SynSent` (отправлен запрос на соединение), что указывает на активную сетевую активность.
  * **`PSCustomObject` и `Format-Table`**: Как и в предыдущих примерах, эти командлеты используются для создания структурированного и удобочитаемого вывода.

Этот скрипт даёт мгновенный снимок сетевой активности. Он очень полезен для быстрой диагностики и может быть легко доработан, например, для фильтрации по определённым IP-адресам или портам, или для сохранения данных в файл для последующего анализа.