
### Скрипт проверки состояния портов

Этот скрипт даст вам полную картину состояния портов в вашей системе.

**Сценарий:** Вы хотите узнать, какие порты прослушиваются на компьютере, и проверить, какие другие порты могут быть доступны для внешних соединений, например, для тестирования брандмауэра.

**Команда, которую можно использовать в Gemini CLI:**

```powershell
gemini-cli "Напиши скрипт PowerShell, который сначала выводит список всех прослушиваемых TCP-портов и процессов, которые их используют. Затем он должен проверять несколько популярных, но не используемых портов (например, 22, 8080) с помощью Test-NetConnection, чтобы узнать, доступны ли они. Выведи информацию в удобочитаемом виде."
```

**Пример сгенерированного скрипта:**

```powershell
Write-Host "--- Мониторинг прослушиваемых и доступных портов ---" -ForegroundColor Green

# 1. Проверка прослушиваемых (открытых и занятых) портов
Write-Host "`nЧасть 1: Список прослушиваемых портов (открытых и занятых):`n" -ForegroundColor Yellow

$listenPorts = Get-NetTCPConnection | Where-Object { $_.State -eq 'Listen' }

if ($listenPorts.Count -eq 0) {
    Write-Host "  Прослушиваемых портов не найдено." -ForegroundColor Green
} else {
    $listenPorts | ForEach-Object {
        $process = Get-Process -Id $_.OwningProcess -ErrorAction SilentlyContinue
        $processName = if ($process) { $process.ProcessName } else { "N/A" }
        
        Write-Host "  - Порт $($_.LocalPort) | Процесс: $processName | Адрес: $($_.LocalAddress)" -ForegroundColor Cyan
    }
}

# 2. Проверка доступности популярных, но не занятых портов
Write-Host "`n`nЧасть 2: Проверка доступности портов (свободных, но потенциально открытых):`n" -ForegroundColor Yellow

# Список портов для проверки. Можно добавить свои порты.
$portsToCheck = 22, 80, 443, 8080

foreach ($port in $portsToCheck) {
    Write-Host "  Проверка порта $port..." -ForegroundColor Cyan
    
    # Test-NetConnection сработает, если порт открыт и доступен.
    $testResult = Test-NetConnection -ComputerName localhost -Port $port -InformationLevel "Detailed" -ErrorAction SilentlyContinue

    if ($testResult -and $testResult.TcpTestSucceeded) {
        Write-Host "  - Порт $port открыт и доступен." -ForegroundColor Red
        Write-Host "    Подключение успешно к $($testResult.RemoteAddress):$($testResult.RemotePort)" -ForegroundColor Magenta
    } else {
        Write-Host "  - Порт $port закрыт или недоступен." -ForegroundColor Green
    }
}

Write-Host "`n--- Мониторинг завершён ---" -ForegroundColor Green
```

### Как это работает?

  * **`Get-NetTCPConnection | Where-Object { $_.State -eq 'Listen' }`**: Эта часть скрипта ищет порты, которые находятся в состоянии прослушивания. Это означает, что какой-то процесс уже использует этот порт и готов принимать входящие соединения.
  * **`Test-NetConnection -ComputerName localhost -Port $port`**: Это мощный командлет для проверки сетевого подключения. Он пытается установить соединение с указанным портом.
      * Если соединение удаётся (`TcpTestSucceeded`), это значит, что порт **открыт** и **прослушивается** (то есть, он *занят* каким-то сервисом).
      * Если соединение не удаётся, это значит, что порт либо **закрыт**, либо **не прослушивается**, либо заблокирован брандмауэром.

Таким образом, скрипт даёт вам два типа информации:

1.  **Точно занятые порты**, которые прослушиваются на компьютере.
2.  **Потенциально открытые порты**, которые могут быть доступны извне, даже если в данный момент не прослушиваются вашей системой.

Вы можете изменить список портов в `$portsToCheck`, чтобы проверить те, которые важны именно для вас.