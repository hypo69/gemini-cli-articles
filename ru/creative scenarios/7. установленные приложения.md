Прекрасно. Это ещё одна важная задача для администраторов и пользователей, которым нужно быстро получить инвентаризацию установленного программного обеспечения. С помощью Gemini CLI можно сгенерировать скрипт, который просканирует реестр Windows, чтобы найти все установленные программы, и представит их в удобном для чтения виде.

Информацию об установленных приложениях Windows хранит в нескольких местах реестра. Наиболее полные списки обычно находятся здесь:

  * **`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall`**: Содержит программы, установленные для всех пользователей системы.
  * **`HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall`**: Содержит программы, установленные только для текущего пользователя.
  * **Ключи для 32-битных программ на 64-битной системе**: `HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall`.

Вот скрипт PowerShell, который объединяет поиск по этим ключам.

-----

### Скрипт инвентаризации установленных приложений

Этот скрипт идеально подходит для создания отчёта об установленном ПО, что полезно для аудита лицензий, проверки на наличие нежелательных программ или просто для получения полного списка всего, что установлено на компьютере.

**Сценарий:** Вам нужно получить полный список всех установленных программ, включая их версии и даты установки.

**Команда, которую можно использовать в Gemini CLI:**

```powershell
gemini-cli "Напиши скрипт PowerShell, который получает список всех установленных приложений. Скрипт должен искать в соответствующих ключах реестра и выводить название приложения, его версию, издателя и дату установки. Список должен быть отсортирован по названию."
```

**Пример сгенерированного скрипта:**

```powershell
Write-Host "--- Список установленных приложений ---" -ForegroundColor Green

# Определяем ключи реестра для поиска
$regPaths = @(
    "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
    "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
    "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
)

# Создаём пустой массив для хранения данных о приложениях
$applications = @()

# Перебираем ключи реестра
foreach ($path in $regPaths) {
    if (Test-Path $path) {
        $items = Get-ChildItem -Path $path -ErrorAction SilentlyContinue | Get-ItemProperty -ErrorAction SilentlyContinue
        
        foreach ($item in $items) {
            # Фильтруем, чтобы исключить элементы, не являющиеся приложениями
            if ($item.DisplayName -and $item.SystemComponent -ne 1) {
                $appName = $item.DisplayName
                $appVersion = $item.DisplayVersion
                $publisher = $item.Publisher
                $installDate = $item.InstallDate

                # Добавляем информацию в массив
                $applications += [PSCustomObject]@{
                    Name = $appName
                    Version = $appVersion
                    Publisher = $publisher
                    InstallDate = $installDate
                }
            }
        }
    }
}

# Сортируем и выводим список
$applications | Sort-Object Name | Format-Table -AutoSize

Write-Host "`n--- Инвентаризация завершена ---" -ForegroundColor Green
```

### Как это работает?

  * **Ключи реестра:** Скрипт ищет в трёх основных ключах реестра, что обеспечивает наиболее полный охват.
  * **`Get-ChildItem` и `Get-ItemProperty`**: Эти командлеты используются для перечисления всех подключей (каждый из которых представляет отдельное приложение) и извлечения их свойств.
  * **Фильтрация**: С помощью `if ($item.DisplayName -and $item.SystemComponent -ne 1)` мы отсеиваем системные компоненты и пустые записи, чтобы получить только реальные, установленные приложения.
  * **`PSCustomObject`**: Это удобный способ создания объектов в PowerShell, позволяющий легко хранить структурированные данные (название, версия, издатель и т.д.).
  * **`Sort-Object` и `Format-Table`**: Эти командлеты делают вывод данных удобным и читабельным. Список сортируется по названию, а `Format-Table -AutoSize` создаёт аккуратную таблицу.

Этот скрипт предоставляет отличную основу для инвентаризации ПО. Вы можете легко изменить его, чтобы сохранить данные в CSV-файл или передать в другую систему для дальнейшего анализа.