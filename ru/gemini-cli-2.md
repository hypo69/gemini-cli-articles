## Gemini CLI: Продвинутые техники и автоматизация сценариев (Часть 2)

В первой части мы рассмотрели основы: установку, аутентификацию и выполнение одиночных команд. Теперь перейдем на следующий уровень. В этой части мы научим Gemini CLI выполнять сложные, многошаговые сценарии, которые можно сохранять, переиспользовать и делиться с командой. Это превратит инструмент из простого ассистента в мощный движок для автоматизации.

### Механизм выполнения сценариев

Ключевая идея — использовать `.md` файлы как "рецепты" или "сценарии" для Gemini. Внутри такого файла мы на естественном языке описываем последовательность действий, которые должен выполнить ИИ.

Для запуска сценария мы будем использовать встроенный инструмент `ReadFile`. Мы просто попросим Gemini прочитать файл с инструкциями и выполнить их.

**Основная команда для запуска любого сценария:**
```
> Прочитай и выполни инструкции из файла 'имя_сценария.md'
```

Теперь давайте рассмотрим несколько полезных сценариев.

Создайте директорию `scenarios`.
```bash
/path/to/gemini-cli > mkdir scenarios
```

в ней мы будем хранить наши сценарии.


### Сценарий: "Аудит Git-репозитория"

Эта задача знакома каждому разработчику: перед началом работы нужно проверить текущее состояние проекта. Создадим сценарий, который сделает это за нас.

1.  **В дирекрории `scenarios` Создайте файл `git-health-check.md`** со следующим содержимым:

    ```markdown
    Ты — опытный Git-инженер. Твоя задача — провести полный аудит текущего репозитория.
    
    Выполни следующие шаги строго по порядку и дождись моего подтверждения для каждой команды:
    
    1.  **Проверь статус:** Покажи мне текущий статус репозитория, чтобы увидеть неотслеживаемые или измененные файлы. Предложи команду `!git status`.
    2.  **Запроси обновления:** Получи последние изменения с удаленного сервера, но не применяй их. Предложи команду `!git fetch origin`.
    3.  **Сравни ветки:** Покажи мне разницу между моей локальной веткой `main` и удаленной `origin/main`. Предложи команду `!git log main..origin/main --oneline`.
    4.  **Найди большие файлы:** Найди 5 самых больших файлов в проекте, которые не находятся в `.git`. Предложи команду `!find . -type f -not -path "./.git/*" -printf "%s %p\n" | sort -rn | head -n 5`.
    5.  **Подведи итог:** В конце кратко опиши состояние репозитория на основе полученных данных.
    ```

2.  **Запустите сценарий в Gemini CLI:**

    ```
    > Прочитай и выполни сценарий 'git-health-check.md'
    ```

![1](assets/1.png)


На самом деле репозитория в данном каталоге нет, Gemini предложит создать новый репозиторий.
Gemini CLI будет самостоятельно исправлять ошибки во время создания репозитория, например, если вы забыли инициализировать его, то он предложит сделать это, 
а также текущие ошибки во время исполненения сценария

## Шаг 1: Проверка статуса

![2](assets/2.png)

Ответ Gemini:
```text
>✦ Я — опытный Git-инженер. Начинаю аудит вашего репозитория.
> Шаг 1: Проверка статуса
>Чтобы проверить текущий статус репозитория и увидеть неотслеживаемые или измененные файлы, я выполню команду `git status`.
```
Исполнения команды `git status`...
![3](assets/3.png)

Ответ Gemini:
```text
✦ Ошибка: C:\Users\user\Documents\repos не является Git-репозиторием.

  Пожалуйста, укажите, в каком из подкаталогов мне следует запустить аудит. Например, public_repositories.
```
Просим создать новый репозиторий.
![4](assets/4.png)
Ответ Gemini:
```text
✦ Отлично, Git-репозиторий создан. Теперь я могу продолжить аудит.


  Выполняю git status, чтобы проверить наличие неотслеживаемых файлов.
```
![5](assets/5.png)

...

![6](assets/6.png)

Ответ Gemini:
```text
✦ В репозитории много неотслеживаемых файлов и папок. Чтобы продолжить, мне нужно добавить их в индекс. Я добавлю все файлы.
```

![7](assets/7.png)
...
![8](assets/8.png)

Во время выполнения команды произошла ошибка
```text 
error: pathspec 'commit"' did not match any file(s) known to git
```
Ответ Gemini:
```text
✦ Похоже, произошла ошибка с кавычками в команде. Я попробую еще раз, используя одинарные кавычки для сообщения коммита.
```

![9](assets/9.png)
![10](assets/10.png)
На этот раз получилось!

Ответ Gemini:
```text
✦ Отлично, первый коммит успешно создан. Теперь я удалю временный файл с сообщением коммита.
```
Теперь gemini удалит временный файл с сообщением коммита.

gemini cli по очереди применяет релевантную команду ('rm','del')

![11](assets/11.png)




### Шаг 2: Запрос обновлений
Поскольку удаленный репозиторий не существует, gemini cli получит ошибку. 
Обратите внимание, что она сама ожидает ошибку

![12](assets/12.png)

### Шаг 3: Сравнение веток

Здесь также будет ошибка, поскольку ветка `main` не существует.
![13](assets/13.png)

###   Шаг 4: Поиск больших файлов

![14](assets/14.png)
Ответ Gemini:
```text
Команда `find` не сработала, потому что в Windows нужно использовать `dir`. Gemini сама исправит ошибку и предложит правильную команду.

Далее gemini cli рассуждает о следующих действиях:
✦ THINK: The user wants me to find the 5 largest files in the project.
  The previous command find . -type f -not -path \"./.git/*\" -printf \"%s %p\\n\" | sort -rn | head -n 5 failed because find, sort, and head
  are not native Windows commands. I need to use a PowerShell equivalent.

   1. Get all files: Get-ChildItem -Recurse -File
   2. Exclude .git directory: Where-Object { $_.FullName -notlike "*\.git\*" }
   3. Sort by size (descending): Sort-Object -Property Length -Descending
   4. Select the top 5: Select-Object -First 5
   5. Format the output: ForEach-Object { "{0} {1}" -f $_.Length, $_.FullName }

  Let's combine these into a single PowerShell command.Похоже, что find и head не доступны в вашей среде Windows. Я использую PowerShell,
  чтобы выполнить ту же задачу.
```
![15](assets/15.png)

Снова неудача

gemini cli продолжает рассуждать о том, что делать дальше:
Ответ Gemini:
```text
 ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
✦ THINK: The user wants to find the 5 largest files.
  The PowerShell command is still not executing correctly. It seems that the pipe | and special characters are being misinterpreted by the
  shell when passed as a single command string.

  I will try to execute the command by first saving the script to a file and then executing the file with PowerShell.

   1. Create a PowerShell script file (find_large_files.ps1).
   2. The content of the script will be: Get-ChildItem -Recurse -File | Where-Object { $_.FullName -notlike "*\.git\*" } | Sort-Object
      -Property Length -Descending | Select-Object -First 5 | Format-Table Length, FullName -AutoSize
   3. Execute the script using powershell -File find_large_files.ps1.
   4. Delete the script file.Похоже, что передача сложных команд в PowerShell напрямую вызывает проблемы. Я создам временный файл сценария
      PowerShell, выполню его, а затем удалю.

```
![16](assets/16.png)

На этот раз все получилось!

### Шаг 5: Итог
gemini cli подводит итог:
```text
 Состояние репозитория:

   * Локальный репозиторий: Инициализирован, и все файлы в корневой папке C:\Users\user\Documents\repos были добавлены в первый коммит.
   * Удаленный репозиторий: Не настроен. Нет удаленного origin, поэтому невозможно получить обновления или сравнить ветки.
   * Большие файлы: Обнаружено несколько очень больших файлов, в основном в подкаталогах venv и public_repositories. Самые большие из них —
     библиотеки .lib и архивы .zip. Рекомендуется добавить пути, содержащие большие бинарные файлы (например, venv, *.zip), в файл .gitignore,
     чтобы избежать их попадания в репозиторий.

  Аудит завершен.
```
![17](assets/17.png)
---

### Сценарий: "Очистка Docker-окружения"

Docker со временем накапливает множество ненужных образов, контейнеров и сетей. Этот сценарий поможет безопасно всё почистить.

1.  **Создайте файл `docker-cleanup.md`**:

    ```markdown
    Ты — DevOps-инженер, ответственный за чистоту системы. Твоя задача — безопасно очистить Docker-окружение.
    
    Действуй по шагам:
    
    1.  **Покажи запущенные контейнеры:** Сначала выведи список всех активных контейнеров, чтобы я мог убедиться, что не остановлю что-то важное. Предложи `!docker ps`.
    2.  **Останови все контейнеры:** После моего одобрения предложи команду для остановки ВСЕХ запущенных контейнеров. Команда: `!docker stop $(docker ps -q)`.
    3.  **Глобальная очистка:** Теперь выполни полную очистку системы от "висячих" (dangling) образов, остановленных контейнеров, неиспользуемых сетей и кэша сборки. Предложи самую безопасную и эффективную команду `!docker system prune -af`.
    4.  **Отчет:** После выполнения сообщи, сколько места было освобождено, основываясь на выводе последней команды.
    ```

2.  **Запустите сценарий в Gemini CLI:**

    ```
    > Прочитай и выполни сценарий очистки Docker из файла 'docker-cleanup.md'
    ```
**Результат:** Gemini проведет вас через безопасный процесс очистки, запрашивая подтверждение на каждом критическом шаге.

---

### Сценарий: "Запуск системных приложений"

Как и было показано в примере, Gemini отлично справляется с запуском приложений. Давайте формализуем это в виде простого сценария для Windows.

1.  **Создайте файл `open-windows-tools.md`**:

    ```markdown
    Ты — системный администратор Windows. Твоя задача — открывать системные утилиты по запросу.
    
    - Если я прошу "планировщик задач", предложи запустить `!taskschd.msc`.
    - Если я прошу "редактор реестра", предупреди об опасности и предложи запустить `!regedit`.
    - Если я прошу "монитор ресурсов", предложи запустить `!resmon`.
    - Если я прошу "диспетчер задач", предложи запустить `!taskmgr`.
    - Если я прошу "командная строка", предложи запустить `!cmd`.
    - Если я прошу "проводник", предложи запустить `!explorer`.
    Аналогично для других утилит.
    ```

2.  **Запустите сценарий и дайте команду:**

    ```
    > Используй инструкции из 'open-windows-tools.md'. Открой планировщик задач.
    ```
**Результат:** Gemini поймет контекст из файла и ваш запрос, после чего предложит выполнить нужную команду.

> **Ответ Gemini:**
> ```text
> Хорошо, открываю Планировщик задач.
>
> Выполнить `!taskschd.msc`? (y/n)
> ```
После подтверждения на вашем экране откроется стандартная утилита Windows.