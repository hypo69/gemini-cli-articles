## Gemini CLI: Просунуті техніки та автоматизація сценаріїв.

У першій частині ми розглянули основи: встановлення, автентифікацію та виконання одиночних команд. Тепер перейдемо на наступний рівень. У цій частині ми навчимо Gemini CLI виконувати складні, багатошагові сценарії, які можна зберігати, повторно використовувати та ділитися з командою. Це перетворить інструмент з простого помічника на потужний двигун для автоматизації.

### Механізм виконання сценаріїв

Ключова ідея — використовувати файли `.md` як "рецепти" або "сценарії" для Gemini. Усередині такого файлу ми природною мовою описуємо послідовність дій, які має виконати ШІ.

Для запуску сценарію ми використовуватимемо вбудований інструмент `ReadFile`. Ми просто попросимо Gemini прочитати файл з інструкціями та виконати їх.

**Основна команда для запуску будь-якого сценарію:**
```
> Прочитайте та виконайте інструкції з файлу 'ім'я_сценарію.md'
```

Тепер давайте розглянемо кілька корисних сценаріїв.

Створіть каталог `scenarios`.
```bash
/path/to/gemini-cli > mkdir scenarios
```

у ньому ми зберігатимемо наші сценарії.


### Сценарій: "Аудит Git-репозиторію"

Це завдання знайоме кожному розробнику: перед початком роботи потрібно перевірити поточний стан проекту. Створимо сценарій, який зробить це за нас.

1.  **У каталозі `scenarios` Створіть файл `git-health-check.md`** з наступним вмістом:

    ```markdown
    Ви — досвідчений Git-інженер. Ваше завдання — провести повний аудит поточного репозиторію. 
    
    Виконайте наступні кроки строго по порядку та дочекайтеся мого підтвердження для кожної команди: 
    
    1.  **Перевірте статус:** Покажіть мені поточний статус репозиторію, щоб побачити невідстежувані або змінені файли. Запропонуйте команду `!git status`.
    2.  **Запитайте оновлення:** Отримайте останні зміни з віддаленого сервера, але не застосовуйте їх. Запропонуйте команду `!git fetch origin`.
    3.  **Порівняйте гілки:** Покажіть мені різницю між моєю локальною гілкою `main` та віддаленою `origin/main`. Запропонуйте команду `!git log main..origin/main --oneline`.
    4.  **Знайдіть великі файли:** Знайдіть 5 найбільших файлів у проекті, які не знаходяться в `.git`. Запропонуйте команду `!find . -type f -not -path "./.git/*" -printf "%s %p\n" | sort -rn | head -n 5`.
    5.  **Підсумуйте:** Наприкінці коротко опишіть стан репозиторію на основі отриманих даних.
    ```

2.  **Запустіть сценарій у Gemini CLI:**

    ```
    > Прочитайте та виконайте сценарій 'git-health-check.md'
    ```

![1](assets/1.png)


Насправді репозиторію в цьому каталозі немає, Gemini запропонує створити новий репозиторій.
Gemini CLI самостійно виправлятиме помилки під час створення репозиторію, наприклад, якщо ви забули ініціалізувати його, то він запропонує зробити це, 
а також поточні помилки під час виконання сценарію.


### Крок 1: Перевірка статусу

![2](assets/2.png)

Відповідь Gemini:
```text
>✦ Я — досвідчений Git-інженер. Починаю аудит вашого репозиторію.
> Крок 1: Перевірка статусу
>Щоб перевірити поточний статус репозиторію та побачити невідстежувані або змінені файли, я виконаю команду `git status`.
```
Виконання команди `git status`...
![3](assets/3.png)

Відповідь Gemini:
```text
✦ Помилка: C:\Users\user\Documents\repos не є Git-репозиторієм. 

  Будь ласка, вкажіть, у якому з підкаталогів мені слід запустити аудит. Наприклад, public_repositories.
```
Просимо створити новий репозиторій.
![4](assets/4.png)
Відповідь Gemini:
```text
✦ Чудово, Git-репозиторій створено. Тепер я можу продовжити аудит. 


  Виконую git status, щоб перевірити наявність невідстежуваних файлів.
```
![5](assets/5.png)

...

![6](assets/6.png)

Відповідь Gemini:
```text
✦ У репозиторії багато невідстежуваних файлів та папок. Щоб продовжити, мені потрібно додати їх до індексу. Я додам усі файли.
```

![7](assets/7.png)
...
![8](assets/8.png)

Під час виконання команди сталася помилка
```text 
error: pathspec 'commit"' did not match any file(s) known to git
```
Відповідь Gemini:
```text
✦ Схоже, сталася помилка з лапками в команді. Я спробую ще раз, використовуючи одинарні лапки для повідомлення комміту.
```

![9](assets/9.png)
![10](assets/10.png)
Цього разу вийшло!

Відповідь Gemini:
```text
✦ Чудово, перший комміт успішно створено. Тепер я видалю тимчасовий файл з повідомленням комміту.
```
Тепер gemini видалить тимчасовий файл з повідомленням комміту.

gemini cli по черзі застосовує релевантну команду ('rm','del')

![11](assets/11.png)




### Крок 2: Запит оновлень
Оскільки віддаленого репозиторію не існує, gemini cli отримає помилку. 
Зверніть увагу, що вона сама очікує помилку.

![12](assets/12.png)


### Крок 3: Порівняння гілок

Тут також буде помилка, оскільки гілка `main` не існує.
![13](assets/13.png)


###   Крок 4: Пошук великих файлів

![14](assets/14.png)
Відповідь Gemini:
```text
Команда `find` не спрацювала, тому що в Windows потрібно використовувати `dir`. Gemini сама виправить помилку та запропонує правильну команду.

Далі gemini cli розмірковує про наступні дії:
✦ THINK: The user wants me to find the 5 largest files in the project.
  The previous command find . -type f -not -path "./.git/*" -printf "%s %p\n" | sort -rn | head -n 5 failed because find, sort, and head
  are not native Windows commands. I need to use a PowerShell equivalent.

   1. Get all files: Get-ChildItem -Recurse -File
   2. Exclude .git directory: Where-Object { $_.FullName -notlike "*\.git\*" }
   3. Sort by size (descending): Sort-Object -Property Length -Descending
   4. Select the top 5: Select-Object -First 5
   5. Format the output: ForEach-Object { "{0} {1}" -f $_.Length, $_.FullName }

  Let's combine these into a single PowerShell command.Схоже, що find та head недоступні у вашому середовищі Windows. Я використовуватиму PowerShell,
  щоб виконати те саме завдання.
```
![15](assets/15.png)

Знову невдача.

gemini cli продовжує розмірковувати про те, що робити далі:
```text
 
✦ THINK: The user wants to find the 5 largest files.
  The PowerShell command is still not executing correctly. It seems that the pipe | and special characters are being misinterpreted by the
  shell when passed as a single command string.

  I will try to execute the command by first saving the script to a file and then executing the file with PowerShell.

   1. Create a PowerShell script file (find_large_files.ps1).
   2. The content of the script will be: Get-ChildItem -Recurse -File | Where-Object { $_.FullName -notlike "*\.git\*" } | Sort-Object
      -Property Length -Descending | Select-Object -First 5 | Format-Table Length, FullName -AutoSize
   3. Execute the script using powershell -File find_large_files.ps1.
   4. Delete the script file.Схоже, що передача складних команд до PowerShell безпосередньо викликає проблеми. Я створю тимчасовий файл сценарію
      PowerShell, виконаю його, а потім видалю.

```
![16](assets/16.png)

Цього разу все вийшло!

### Крок 5: Підсумок
gemini cli підсумовує:
```text
 Стан репозиторію:

   * Локальний репозиторій: Ініціалізовано, і всі файли в кореневій папці C:\Users\user\Documents\repos були додані до першого комміту.
   * Віддалений репозиторій: Не налаштований. Немає віддаленого origin, тому неможливо отримати оновлення або порівняти гілки.
   * Великі файли: Виявлено кілька дуже великих файлів, в основному в підкаталогах venv та public_repositories. Найбільші з них —
     бібліотеки .lib та архіви .zip. Рекомендується додати шляхи, що містять великі бінарні файли (наприклад, venv, *.zip), до файлу .gitignore,
     щоб уникнути їх потрапляння до репозиторію.

  Аудит завершено.
```
![17](assets/17.png)


### Сценарій: "Очищення Docker-оточення"

Docker з часом накопичує багато непотрібних образів, контейнерів та мереж. Цей сценарій допоможе безпечно все почистити.

1.  **Створіть файл `docker-cleanup.md`**:

    ```markdown
    Ви — DevOps-інженер, відповідальний за чистоту системи. Ваше завдання — безпечно очистити Docker-оточення. 
    
    Дійте по кроках: 
    
    1.  **Покажіть запущені контейнери:** Спочатку виведіть список усіх активних контейнерів, щоб я міг переконатися, що не зупиню щось важливе. Запропонуйте `!docker ps`.
    2.  **Зупиніть усі контейнери:** Після мого схвалення запропонуйте команду для зупинки УСІХ запущених контейнерів. Команда: `!docker stop $(docker ps -q)`.
    3.  **Глобальне очищення:** Тепер виконайте повне очищення системи від "висячих" (dangling) образів, зупинених контейнерів, невикористовуваних мереж та кешу збірки. Запропонуйте найбезпечнішу та найефективнішу команду `!docker system prune -af`.
    4.  **Звіт:** Після виконання повідомте, скільки місця було звільнено, ґрунтуючись на виводі останньої команди.
    ```

2.  **Запустіть сценарій у Gemini CLI:**

    ```
    > Прочитайте та виконайте сценарій очищення Docker з файлу 'docker-cleanup.md'
    ```
**Результат:** Gemini проведе вас через безпечний процес очищення, запитуючи підтвердження на кожному критичному кроці.

---


### Сценарій: "Запуск системних додатків"

Як і було показано в прикладі, Gemini чудово справляється із запуском додатків. Давайте формалізуємо це у вигляді простого сценарію для Windows.

1.  **Створіть файл `open-windows-tools.md`**:

    ```markdown
    Ви — системний адміністратор Windows. Ваше завдання — відкривати системні утиліти за запитом. 
    
    - Якщо я прошу "планувальник завдань", запропонуйте запустити `!taskschd.msc`.
    - Якщо я прошу "редактор реєстру", попередьте про небезпеку та запропонуйте запустити `!regedit`.
    - Якщо я прошу "монітор ресурсів", запропонуйте запустити `!resmon`.
    - Якщо я прошу "диспетчер завдань", запропонуйте запустити `!taskmgr`.
    - Якщо я прошу "командний рядок", запропонуйте запустити `!cmd`.
    - Якщо я прошу "провідник", запропонуйте запустити `!explorer`.
    Аналогічно для інших утиліт.
    ```

2.  **Запустіть сценарій та дайте команду:**

    ```
    > Використовуйте інструкції з 'open-windows-tools.md'. Відкрийте планувальник завдань.
    ```
**Результат:** Gemini зрозуміє контекст з файлу та ваш запит, після чого запропонує виконати потрібну команду.

> **Відповідь Gemini:**
> ```text
> Добре, відкриваю Планувальник завдань. 
> 
> Виконати `!taskschd.msc`? (y/n)
> ```
Після підтвердження на вашому екрані відкриється стандартна утиліта Windows.
